<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Learn Data Structures</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      /* Custom styles (consistent with previous tutorials) */
      body {
        font-family: "Inter", sans-serif;
      }
      pre {
        background-color: #f3f4f6; /* gray-100 */
        border: 1px solid #e5e7eb; /* gray-200 */
        border-radius: 0.375rem; /* rounded-md */
        padding: 1rem; /* p-4 */
        overflow-x: auto;
        font-family: monospace;
        font-size: 0.875rem; /* text-sm */
        margin-top: 0.5rem; /* mt-2 */
        margin-bottom: 1rem; /* mb-4 */
        position: relative;
      }
      code {
        font-family: monospace;
        background-color: rgba(209, 213, 219, 0.3); /* gray-300 with opacity */
        padding: 0.1rem 0.3rem;
        border-radius: 0.25rem;
      }
      pre code {
        /* Don't style code inside pre differently */
        background-color: transparent;
        padding: 0;
        border-radius: 0;
      }
      .interactive-section {
        background-color: #ffffff; /* white */
        padding: 1.5rem; /* p-6 */
        border-radius: 0.5rem; /* rounded-lg */
        box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1),
          0 1px 2px 0 rgba(0, 0, 0, 0.06); /* shadow-md */
        margin-bottom: 1.5rem; /* mb-6 */
      }
      .btn {
        background-color: #3b82f6; /* blue-500 */
        color: white;
        padding: 0.5rem 1rem; /* py-2 px-4 */
        border-radius: 0.375rem; /* rounded-md */
        font-weight: 500; /* font-medium */
        cursor: pointer;
        transition: background-color 0.2s ease;
        border: none;
        margin-right: 0.5rem; /* mr-2 */
        margin-top: 0.5rem; /* Add some top margin for buttons */
      }
      .btn:hover:not(:disabled) {
        background-color: #2563eb; /* blue-600 */
      }
      .btn:disabled {
        background-color: #9ca3af; /* gray-400 */
        cursor: not-allowed;
      }
      .btn-green {
        background-color: #22c55e; /* green-500 */
      }
      .btn-green:hover:not(:disabled) {
        background-color: #16a34a; /* green-600 */
      }
      .btn-red {
        background-color: #ef4444; /* red-500 */
      }
      .btn-red:hover:not(:disabled) {
        background-color: #dc2626; /* red-600 */
      }
      .btn-purple {
        background-color: #8b5cf6; /* violet-500 */
      }
      .btn-purple:hover:not(:disabled) {
        background-color: #7c3aed; /* violet-600 */
      }
      .input-field,
      .select-field {
        border: 1px solid #d1d5db; /* gray-300 */
        padding: 0.5rem; /* p-2 */
        border-radius: 0.375rem; /* rounded-md */
        margin-right: 0.5rem; /* mr-2 */
        margin-top: 0.25rem; /* mt-1 */
        margin-bottom: 0.5rem; /* mb-2 */
      }
      .message-box {
        margin-top: 1rem; /* mt-4 */
        padding: 0.75rem; /* p-3 */
        border-radius: 0.375rem; /* rounded-md */
        font-size: 0.875rem; /* text-sm */
      }
      .message-box-success {
        background-color: #dcfce7; /* green-100 */
        color: #166534; /* green-800 */
        border: 1px solid #86efac; /* green-300 */
      }
      .message-box-error {
        background-color: #fee2e2; /* red-100 */
        color: #991b1b; /* red-800 */
        border: 1px solid #fecaca; /* red-300 */
      }
      .message-box-info {
        background-color: #e0f2fe; /* sky-100 */
        color: #075985; /* sky-800 */
        border: 1px solid #bae6fd; /* sky-300 */
      }
      .output-display {
        background-color: #f9fafb; /* gray-50 */
        border: 1px dashed #d1d5db; /* gray-300 */
        padding: 1rem; /* p-4 */
        border-radius: 0.375rem; /* rounded-md */
        min-height: 50px;
        font-family: monospace;
        white-space: pre-wrap; /* Keep formatting */
        margin-top: 0.5rem; /* mt-2 */
        max-height: 250px;
        overflow-y: auto;
      }
      /* Visualization Styles */
      .data-structure-container {
        background-color: #f3f4f6; /* gray-100 */
        padding: 1rem;
        border-radius: 0.375rem;
        margin-top: 1rem;
        min-height: 60px;
        display: flex;
        gap: 4px; /* Space between items */
        border: 1px solid #e5e7eb; /* gray-200 */
        flex-wrap: wrap;
        align-items: center; /* Center items vertically */
      }
      .ds-item {
        /* Generic item style */
        border: 1px solid #9ca3af; /* gray-400 */
        background-color: #fff; /* white */
        color: #374151; /* gray-700 */
        padding: 0.5rem 0.8rem;
        margin: 2px;
        border-radius: 4px;
        font-family: monospace;
        min-width: 35px;
        text-align: center;
        transition: background-color 0.3s ease, border-color 0.3s ease,
          transform 0.2s ease, opacity 0.3s ease;
      }
      /* Stack specific */
      .stack-container {
        flex-direction: column-reverse; /* Stack grows upwards */
        align-items: center;
        min-width: 80px; /* Ensure some width */
        min-height: 150px;
        justify-content: flex-start; /* Align items at the bottom */
      }
      .stack-item {
        width: 80%;
        margin-bottom: 4px;
      } /* Stack items wider */
      .stack-item.top {
        border: 2px solid #fbbf24; /* amber-400 */
        font-weight: bold;
      }

      /* Queue specific */
      .queue-container {
        justify-content: flex-start; /* Align items to the left */
        align-items: center;
        padding-left: 1rem;
        padding-right: 1rem;
      }
      .queue-item.front {
        border: 2px solid #fbbf24; /* amber-400 */
        font-weight: bold;
      }
      .queue-item.rear {
        border: 2px solid #a78bfa; /* violet-400 */
        font-weight: bold;
      }

      /* Set specific */
      .set-container {
        justify-content: center;
      }
      .set-item.highlight {
        background-color: #fcd34d;
        border-color: #f59e0b;
      }
    </style>
  </head>
  <body class="bg-gray-50 text-gray-800 p-4 md:p-8">
    <header class="text-center mb-8">
      <h1 class="text-3xl md:text-4xl font-bold text-blue-600">
        Understanding Data Structures
      </h1>
      <p class="text-lg text-gray-600 mt-2">
        An Interactive Overview (Sets, Stacks, Queues, and more)
      </p>
    </header>

    <main class="max-w-4xl mx-auto">
      <section class="mb-8">
        <h2 class="text-2xl font-semibold text-gray-700 mb-3">
          1. What are Data Structures?
        </h2>
        <p class="mb-4">
          Data structures are specialized formats for **organizing, processing,
          retrieving, and storing data**. Just like you might organize clothes
          in a dresser or books on a shelf, data structures provide ways to
          arrange data in a computer's memory efficiently.
        </p>
        <p>
          Choosing the right data structure is crucial because it can
          significantly impact:
        </p>
        <ul class="list-disc list-inside ml-4 space-y-1">
          <li>
            <strong>Efficiency:</strong> How quickly operations like adding,
            removing, or searching for data can be performed.
          </li>
          <li>
            <strong>Memory Usage:</strong> How much space the data takes up.
          </li>
          <li>
            <strong>Code Clarity:</strong> How easy it is to work with the data
            and understand the code.
          </li>
        </ul>
        <p class="mt-2">
          Different data structures are suited for different kinds of problems.
        </p>
      </section>

      <section class="mb-8">
        <h2 class="text-2xl font-semibold text-gray-700 mb-3">
          2. Common Built-in Structures (Recap)
        </h2>
        <p class="mb-2">
          Python comes with several powerful built-in data structures that we've
          explored previously:
        </p>
        <ul class="list-disc list-inside ml-4 space-y-1 text-sm">
          <li>
            <strong>Lists (<code>list</code>):</strong> Ordered, mutable
            (changeable) sequences. Great for collections where order matters
            and items might change. Accessed by index.
          </li>
          <li>
            <strong>Tuples (<code>tuple</code>):</strong> Ordered, immutable
            (unchangeable) sequences. Useful for fixed collections of related
            items, like coordinates. Accessed by index.
          </li>
          <li>
            <strong>Dictionaries (<code>dict</code>):</strong> Unordered
            (historically) collections of key-value pairs. Mutable. Excellent
            for lookups when you have a unique key associated with a value.
            Accessed by key.
          </li>
        </ul>
        <p class="mt-2 text-sm text-gray-600">
          Refer back to the specific tutorials for detailed interactive examples
          of these.
        </p>
      </section>

      <section class="mb-8 interactive-section">
        <h2 class="text-2xl font-semibold text-gray-700 mb-3">3. Sets (set)</h2>
        <p class="mb-2">
          A set is an **unordered collection of unique items**. Think of it like
          a mathematical set.
        </p>
        <p class="mb-2">Key characteristics:</p>
        <ul class="list-disc list-inside ml-4 space-y-1">
          <li>
            <strong>Unordered:</strong> Items don't have a specific position or
            index.
          </li>
          <li>
            <strong>Unique Elements:</strong> Duplicate items are automatically
            removed.
          </li>
          <li>
            <strong>Mutable:</strong> You can add or remove elements after
            creation.
          </li>
          <li>
            <strong>Fast Membership Testing:</strong> Very efficient for
            checking if an item exists within the set (<code>in</code>
            operator).
          </li>
        </ul>
        <pre><code class="language-python"># Create a set (duplicates are removed)
my_set = {1, 2, 3, 2, 4, 1}
print(my_set) # Output: {1, 2, 3, 4} (order may vary)

# Add an element
my_set.add(5)
print(my_set) # Output: {1, 2, 3, 4, 5}

# Remove an element
my_set.remove(3) # Raises KeyError if item not found
# my_set.discard(10) # Doesn't raise error if item not found
print(my_set) # Output: {1, 2, 4, 5}

# Check membership
print(4 in my_set) # Output: True
print(10 in my_set) # Output: False</code></pre>

        <h3 class="text-lg font-medium mt-4 mb-2">Try Set Operations:</h3>
        <div class="flex flex-wrap items-center mb-2">
          <label for="setItemInput" class="mr-2">Item:</label>
          <input
            type="text"
            id="setItemInput"
            class="input-field"
            placeholder="e.g., apple"
          />
          <button id="addToSetButton" class="btn btn-green">Add to Set</button>
          <button id="removeFromSetButton" class="btn btn-red">
            Remove from Set
          </button>
          <button id="checkInSetButton" class="btn">Check if In Set</button>
        </div>
        <h4 class="text-md font-medium mt-3 mb-1">Current Set:</h4>
        <div
          id="setContainer"
          class="data-structure-container set-container"
        ></div>
        <div id="setResultDisplay" class="output-display">
          <span class="text-gray-500 italic">Perform an operation.</span>
        </div>
        <div id="setMessage" class="message-box" style="display: none"></div>
      </section>

      <section class="mb-8 interactive-section">
        <h2 class="text-2xl font-semibold text-gray-700 mb-3">
          4. Stacks (LIFO)
        </h2>
        <p class="mb-2">
          A stack is a linear data structure that follows the **Last-In,
          First-Out (LIFO)** principle. Think of a stack of plates: the last
          plate you put on top is the first one you take off.
        </p>
        <p class="mb-2">Main operations:</p>
        <ul class="list-disc list-inside ml-4 space-y-1">
          <li><strong>Push:</strong> Add an item to the top of the stack.</li>
          <li>
            <strong>Pop:</strong> Remove and return the item from the top of the
            stack.
          </li>
          <li>
            <strong>Peek (or Top):</strong> View the top item without removing
            it.
          </li>
        </ul>
        <p class="mt-2 text-sm text-gray-600">
          In Python, lists can be easily used to implement stacks, using
          <code>append()</code> for push and <code>pop()</code> (without an
          index) for pop.
        </p>
        <pre><code class="language-python">my_stack = []

# Push items
my_stack.append('A')
my_stack.append('B')
my_stack.append('C')
print(f"Stack after pushes: {my_stack}") # Output: ['A', 'B', 'C']

# Peek (view top item)
top_item = my_stack[-1]
print(f"Top item (peek): {top_item}") # Output: C

# Pop item
removed_item = my_stack.pop()
print(f"Popped item: {removed_item}") # Output: C
print(f"Stack after pop: {my_stack}") # Output: ['A', 'B']</code></pre>

        <h3 class="text-lg font-medium mt-4 mb-2">Try Stack Operations:</h3>
        <div class="flex flex-wrap items-center mb-2">
          <label for="stackItemInput" class="mr-2">Item to Push:</label>
          <input
            type="text"
            id="stackItemInput"
            class="input-field"
            placeholder="e.g., X"
          />
          <button id="pushButton" class="btn btn-green">Push onto Stack</button>
          <button id="popButton" class="btn btn-red">Pop from Stack</button>
          <button id="peekStackButton" class="btn">Peek Top</button>
        </div>
        <h4 class="text-md font-medium mt-3 mb-1">
          Current Stack (Top is Up):
        </h4>
        <div
          id="stackContainer"
          class="data-structure-container stack-container"
        ></div>
        <div id="stackResultDisplay" class="output-display">
          <span class="text-gray-500 italic">Perform an operation.</span>
        </div>
        <div id="stackMessage" class="message-box" style="display: none"></div>
      </section>

      <section class="mb-8 interactive-section">
        <h2 class="text-2xl font-semibold text-gray-700 mb-3">
          5. Queues (FIFO)
        </h2>
        <p class="mb-2">
          A queue is a linear data structure that follows the **First-In,
          First-Out (FIFO)** principle. Think of a queue or line for a checkout:
          the first person in line is the first person served.
        </p>
        <p class="mb-2">Main operations:</p>
        <ul class="list-disc list-inside ml-4 space-y-1">
          <li>
            <strong>Enqueue:</strong> Add an item to the rear (end) of the
            queue.
          </li>
          <li>
            <strong>Dequeue:</strong> Remove and return the item from the front
            of the queue.
          </li>
          <li>
            <strong>Peek (or Front):</strong> View the front item without
            removing it.
          </li>
        </ul>
        <p class="mt-2 text-sm text-gray-600">
          While lists can be used, popping from the beginning of a list
          (<code>list.pop(0)</code>) is inefficient (O(n)). Python's
          <code>collections.deque</code> (double-ended queue) is optimized for
          fast appends and pops from both ends, making it ideal for implementing
          queues.
        </p>
        <pre><code class="language-python">from collections import deque

my_queue = deque()

# Enqueue items
my_queue.append('Task 1') # Add to the right (rear)
my_queue.append('Task 2')
my_queue.append('Task 3')
print(f"Queue after enqueues: {my_queue}") # Output: deque(['Task 1', 'Task 2', 'Task 3'])

# Peek (view front item)
front_item = my_queue[0]
print(f"Front item (peek): {front_item}") # Output: Task 1

# Dequeue item
removed_item = my_queue.popleft() # Remove from the left (front)
print(f"Dequeued item: {removed_item}") # Output: Task 1
print(f"Queue after dequeue: {my_queue}") # Output: deque(['Task 2', 'Task 3'])</code></pre>

        <h3 class="text-lg font-medium mt-4 mb-2">Try Queue Operations:</h3>
        <div class="flex flex-wrap items-center mb-2">
          <label for="queueItemInput" class="mr-2">Item to Enqueue:</label>
          <input
            type="text"
            id="queueItemInput"
            class="input-field"
            placeholder="e.g., P1"
          />
          <button id="enqueueButton" class="btn btn-green">
            Enqueue (Add Rear)
          </button>
          <button id="dequeueButton" class="btn btn-red">
            Dequeue (Remove Front)
          </button>
          <button id="peekQueueButton" class="btn">Peek Front</button>
        </div>
        <h4 class="text-md font-medium mt-3 mb-1">
          Current Queue (Front is Left):
        </h4>
        <div
          id="queueContainer"
          class="data-structure-container queue-container"
        ></div>
        <div id="queueResultDisplay" class="output-display">
          <span class="text-gray-500 italic">Perform an operation.</span>
        </div>
        <div id="queueMessage" class="message-box" style="display: none"></div>
      </section>

      <section class="mb-8">
        <h2 class="text-2xl font-semibold text-gray-700 mb-3">
          6. Other Important Data Structures (Briefly)
        </h2>
        <p class="mb-2">Beyond the basics, other important structures exist:</p>
        <ul class="list-disc list-inside ml-4 space-y-2 text-sm">
          <li>
            <strong>Linked Lists:</strong> Linear collections where elements
            (nodes) are linked using pointers, rather than being stored
            contiguously in memory like lists/arrays. Allows efficient
            insertions/deletions in the middle but slower access by index.
          </li>
          <li>
            <strong>Trees:</strong> Hierarchical structures with a root node and
            child nodes branching out. Used for representing hierarchies (file
            systems), efficient searching (Binary Search Trees), and more.
          </li>
          <li>
            <strong>Graphs:</strong> Collections of nodes (vertices) connected
            by edges. Used to model networks (social networks, road maps,
            computer networks).
          </li>
          <li>
            <strong>Hash Tables (underlying Dictionaries):</strong> Use a hash
            function to map keys to indices in an array, providing very fast
            average-case lookups, insertions, and deletions.
          </li>
        </ul>
      </section>

      <section class="mb-8 interactive-section">
        <h2 class="text-2xl font-semibold text-gray-700 mb-3">7. Quick Quiz</h2>
        <p class="mb-4">Test your understanding!</p>
        <div class="mb-3">
          <p class="font-medium mb-1">
            Q1: Which data structure guarantees that all its elements are
            unique?
          </p>
          <label class="block"
            ><input type="radio" name="q1_ds" value="a" class="mr-1" />
            List</label
          >
          <label class="block"
            ><input type="radio" name="q1_ds" value="b" class="mr-1" />
            Set</label
          >
          <label class="block"
            ><input type="radio" name="q1_ds" value="c" class="mr-1" />
            Tuple</label
          >
        </div>
        <div class="mb-3">
          <p class="font-medium mb-1">
            Q2: What does LIFO stand for, and which structure follows it?
          </p>
          <label class="block"
            ><input type="radio" name="q2_ds" value="a" class="mr-1" /> Last-In,
            First-Out (Queue)</label
          >
          <label class="block"
            ><input type="radio" name="q2_ds" value="b" class="mr-1" />
            First-In, First-Out (Stack)</label
          >
          <label class="block"
            ><input type="radio" name="q2_ds" value="c" class="mr-1" /> Last-In,
            First-Out (Stack)</label
          >
        </div>
        <div class="mb-3">
          <p class="font-medium mb-1">
            Q3: Adding an element to the end of a queue is called:
          </p>
          <label class="block"
            ><input type="radio" name="q3_ds" value="a" class="mr-1" />
            Push</label
          >
          <label class="block"
            ><input type="radio" name="q3_ds" value="b" class="mr-1" />
            Enqueue</label
          >
          <label class="block"
            ><input type="radio" name="q3_ds" value="c" class="mr-1" />
            Append</label
          >
        </div>
        <div class="mb-3">
          <p class="font-medium mb-1">
            Q4: Which Python collection type is generally best suited for
            implementing an efficient queue?
          </p>
          <label class="block"
            ><input type="radio" name="q4_ds" value="a" class="mr-1" />
            `list`</label
          >
          <label class="block"
            ><input type="radio" name="q4_ds" value="b" class="mr-1" />
            `tuple`</label
          >
          <label class="block"
            ><input type="radio" name="q4_ds" value="c" class="mr-1" />
            `collections.deque`</label
          >
        </div>
        <button id="checkQuizButtonDS" class="btn">Check Answers</button>
        <div
          id="quizResultDS"
          class="message-box mt-4"
          style="display: none"
        ></div>
      </section>
    </main>

    <footer class="text-center mt-12 text-gray-500 text-sm">
      <p>Happy Learning!</p>
    </footer>

    <script>
      // --- Shared Utility Functions ---
      function showMessage(element, message, type = "info") {
        element.textContent = message;
        element.className = `message-box message-box-${type}`;
        element.style.display = "block";
        setTimeout(() => {
          element.style.display = "none";
        }, 3000);
      }

      // --- DOM Elements ---
      const setItemInput = document.getElementById("setItemInput");
      const addToSetButton = document.getElementById("addToSetButton");
      const removeFromSetButton = document.getElementById(
        "removeFromSetButton"
      );
      const checkInSetButton = document.getElementById("checkInSetButton");
      const setContainer = document.getElementById("setContainer");
      const setResultDisplay = document.getElementById("setResultDisplay");
      const setMessage = document.getElementById("setMessage");

      const stackItemInput = document.getElementById("stackItemInput");
      const pushButton = document.getElementById("pushButton");
      const popButton = document.getElementById("popButton");
      const peekStackButton = document.getElementById("peekStackButton");
      const stackContainer = document.getElementById("stackContainer");
      const stackResultDisplay = document.getElementById("stackResultDisplay");
      const stackMessage = document.getElementById("stackMessage");

      const queueItemInput = document.getElementById("queueItemInput");
      const enqueueButton = document.getElementById("enqueueButton");
      const dequeueButton = document.getElementById("dequeueButton");
      const peekQueueButton = document.getElementById("peekQueueButton");
      const queueContainer = document.getElementById("queueContainer");
      const queueResultDisplay = document.getElementById("queueResultDisplay");
      const queueMessage = document.getElementById("queueMessage");

      const checkQuizButtonDS = document.getElementById("checkQuizButtonDS");
      const quizResultDS = document.getElementById("quizResultDS");

      // --- State ---
      let interactiveSet = new Set(["apple", "banana", "cherry"]);
      let interactiveStack = ["A", "B"]; // Simulate stack with array (top is end)
      let interactiveQueue = ["P1", "P2"]; // Simulate queue with array (front is start)

      // --- Set Logic ---
      function renderSet() {
        setContainer.innerHTML = ""; // Clear previous
        if (interactiveSet.size === 0) {
          setContainer.innerHTML =
            '<span class="text-gray-500 italic">Set is empty</span>';
          return;
        }
        interactiveSet.forEach((item) => {
          const span = document.createElement("span");
          span.className = "ds-item set-item";
          span.textContent = item;
          setContainer.appendChild(span);
        });
      }

      addToSetButton.addEventListener("click", () => {
        const item = setItemInput.value.trim();
        if (!item) {
          showMessage(setMessage, "Please enter an item to add.", "error");
          return;
        }
        const added = !interactiveSet.has(item); // Check if it's already there
        interactiveSet.add(item);
        renderSet();
        setResultDisplay.textContent = `Added "${item}". ${
          added ? "" : "(Item was already in set)"
        }`;
        setItemInput.value = "";
        showMessage(
          setMessage,
          `Item "${item}" added (or already present).`,
          "success"
        );
      });

      removeFromSetButton.addEventListener("click", () => {
        const item = setItemInput.value.trim();
        if (!item) {
          showMessage(setMessage, "Please enter an item to remove.", "error");
          return;
        }
        const removed = interactiveSet.delete(item); // delete returns true if item was present
        renderSet();
        if (removed) {
          setResultDisplay.textContent = `Removed "${item}".`;
          showMessage(setMessage, `Item "${item}" removed.`, "success");
        } else {
          setResultDisplay.textContent = `Item "${item}" not found in set.`;
          showMessage(setMessage, `Item "${item}" not found.`, "error");
        }
        setItemInput.value = "";
      });

      checkInSetButton.addEventListener("click", () => {
        const item = setItemInput.value.trim();
        if (!item) {
          showMessage(setMessage, "Please enter an item to check.", "error");
          return;
        }
        const isInSet = interactiveSet.has(item);
        renderSet(); // Re-render to clear previous highlights
        setResultDisplay.textContent = `Is "${item}" in the set? ${isInSet}`;
        // Highlight if found
        if (isInSet) {
          setContainer.querySelectorAll(".set-item").forEach((span) => {
            if (span.textContent === item) {
              span.classList.add("highlight");
            }
          });
        }
        showMessage(setMessage, `Checked for "${item}".`, "info");
      });

      // --- Stack Logic ---
      function renderStack() {
        stackContainer.innerHTML = ""; // Clear previous
        if (interactiveStack.length === 0) {
          stackContainer.innerHTML =
            '<span class="text-gray-500 italic">Stack is empty</span>';
          return;
        }
        // Render bottom-up visually
        interactiveStack.forEach((item, index) => {
          const span = document.createElement("span");
          span.className = "ds-item stack-item";
          span.textContent = item;
          if (index === interactiveStack.length - 1) {
            span.classList.add("top"); // Mark the top item
          }
          stackContainer.appendChild(span);
        });
      }

      pushButton.addEventListener("click", () => {
        const item = stackItemInput.value.trim();
        if (!item) {
          showMessage(stackMessage, "Please enter an item to push.", "error");
          return;
        }
        interactiveStack.push(item);
        renderStack();
        stackResultDisplay.textContent = `Pushed "${item}" onto the stack.`;
        stackItemInput.value = "";
        showMessage(stackMessage, "Item pushed.", "success");
      });

      popButton.addEventListener("click", () => {
        if (interactiveStack.length === 0) {
          stackResultDisplay.textContent = "Stack is empty. Cannot pop.";
          showMessage(stackMessage, "Stack is empty.", "error");
          return;
        }
        const poppedItem = interactiveStack.pop();
        renderStack();
        stackResultDisplay.textContent = `Popped "${poppedItem}" from the stack.`;
        showMessage(stackMessage, "Item popped.", "success");
      });

      peekStackButton.addEventListener("click", () => {
        renderStack(); // Ensure top is marked
        if (interactiveStack.length === 0) {
          stackResultDisplay.textContent = "Stack is empty.";
          showMessage(stackMessage, "Stack is empty.", "info");
        } else {
          const topItem = interactiveStack[interactiveStack.length - 1];
          stackResultDisplay.textContent = `Top item is "${topItem}".`;
          showMessage(stackMessage, "Peeked at top item.", "info");
        }
      });

      // --- Queue Logic ---
      function renderQueue() {
        queueContainer.innerHTML = ""; // Clear previous
        if (interactiveQueue.length === 0) {
          queueContainer.innerHTML =
            '<span class="text-gray-500 italic">Queue is empty</span>';
          return;
        }
        interactiveQueue.forEach((item, index) => {
          const span = document.createElement("span");
          span.className = "ds-item queue-item";
          span.textContent = item;
          if (index === 0) {
            span.classList.add("front"); // Mark the front item
          }
          if (index === interactiveQueue.length - 1) {
            span.classList.add("rear"); // Mark the rear item
          }
          queueContainer.appendChild(span);
        });
      }

      enqueueButton.addEventListener("click", () => {
        const item = queueItemInput.value.trim();
        if (!item) {
          showMessage(
            queueMessage,
            "Please enter an item to enqueue.",
            "error"
          );
          return;
        }
        interactiveQueue.push(item); // Add to the end (rear)
        renderQueue();
        queueResultDisplay.textContent = `Enqueued "${item}" to the rear.`;
        queueItemInput.value = "";
        showMessage(queueMessage, "Item enqueued.", "success");
      });

      dequeueButton.addEventListener("click", () => {
        if (interactiveQueue.length === 0) {
          queueResultDisplay.textContent = "Queue is empty. Cannot dequeue.";
          showMessage(queueMessage, "Queue is empty.", "error");
          return;
        }
        const dequeuedItem = interactiveQueue.shift(); // Remove from the front
        renderQueue();
        queueResultDisplay.textContent = `Dequeued "${dequeuedItem}" from the front.`;
        showMessage(queueMessage, "Item dequeued.", "success");
      });

      peekQueueButton.addEventListener("click", () => {
        renderQueue(); // Ensure front is marked
        if (interactiveQueue.length === 0) {
          queueResultDisplay.textContent = "Queue is empty.";
          showMessage(queueMessage, "Queue is empty.", "info");
        } else {
          const frontItem = interactiveQueue[0];
          queueResultDisplay.textContent = `Front item is "${frontItem}".`;
          showMessage(queueMessage, "Peeked at front item.", "info");
        }
      });

      // --- Quiz Logic ---
      function checkDSQuiz() {
        const answers = {
          q1_ds: "b", // Set
          q2_ds: "c", // LIFO (Stack)
          q3_ds: "b", // Enqueue
          q4_ds: "c", // collections.deque
        };
        let score = 0;
        let resultsHTML = "<ul>";
        let allAnswered = true;

        for (const q in answers) {
          const selected = document.querySelector(`input[name="${q}"]:checked`);
          if (!selected) {
            allAnswered = false;
            break;
          }
          const isCorrect = selected.value === answers[q];
          if (isCorrect) {
            score++;
            resultsHTML += `<li class="text-green-700">✓ Question ${q.substring(
              1,
              2
            )}: Correct!</li>`;
          } else {
            resultsHTML += `<li class="text-red-700">✗ Question ${q.substring(
              1,
              2
            )}: Incorrect.</li>`;
          }
        }

        if (!allAnswered) {
          quizResultDS.textContent =
            "Please answer all questions before checking.";
          quizResultDS.className = "message-box message-box-error";
          quizResultDS.style.display = "block";
          return;
        }

        resultsHTML += "</ul>";
        resultsHTML =
          `<p class="font-medium mb-2">You scored ${score} out of ${
            Object.keys(answers).length
          }.</p>` + resultsHTML;

        quizResultDS.innerHTML = resultsHTML;
        quizResultDS.className =
          score === Object.keys(answers).length
            ? "message-box message-box-success"
            : "message-box message-box-error";
        quizResultDS.style.display = "block";
      }

      // --- Event Listeners ---
      checkQuizButtonDS.addEventListener("click", checkDSQuiz);

      // --- Initial Setup ---
      window.onload = () => {
        renderSet();
        renderStack();
        renderQueue();
      };
    </script>
  </body>
</html>
