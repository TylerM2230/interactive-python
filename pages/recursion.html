<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Recursion - Python Guide</title>
    <!-- <script src="https://cdn.tailwindcss.com"></script> -->
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/shared-styles.css">
  </head>
  <body class="min-h-screen">
    <div class="console-screen-border">
      <header class="text-center mb-12 md:mb-16">
        <h1 class="pixel-header">
          Interactive Python Guide
        </h1>
        <p class="pixel-subheader mt-4">
          Retro Journey into Code!
        </p>
      </header>

      <main class="mx-auto">
        <h1 class="page-title-8bit">
          Understanding Recursion
        </h1>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            1. What is Recursion?
          </h2>
          <div class="sub-interactive-box">
            <p>
              Recursion is a powerful programming technique where a function calls itself in order to solve a problem. Instead of using iterative loops (like <code>for</code> or <code>while</code>) to repeat a set of operations, a recursive function breaks the problem down into smaller, self-similar subproblems. It continues to do so until it reaches a simple, elementary case that can be solved directly, without further recursion.
            </p>
            <p>
              A common analogy is Russian nesting dolls (Matryoshka dolls): each doll contains a smaller, identical version of itself, until you reach the smallest doll that cannot be opened further. This smallest doll represents the "base case" in recursion.
            </p>
            <p>A recursive function must have two key components:</p>
            <ul>
              <li>
                <strong>Base Case(s):</strong> This is one or more conditions that define the simplest version of the problem. When a base case is met, the function returns a result directly without making another recursive call. The base case is crucial for stopping the chain of recursive calls and preventing infinite loops.
              </li>
              <li>
                <strong>Recursive Step (or Recursive Case):</strong> This is the part of the function where it calls itself, but with modified arguments that progress towards a base case. The problem is typically reduced in size or complexity with each recursive call.
              </li>
            </ul>
          </div>
        </section>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            2. Base Case and Recursive Step: The Factorial Example
          </h2>
          <div class="sub-interactive-box">
            <p>
              Calculating the factorial of a non-negative integer `n` (denoted as `n!`) is a classic example used to illustrate recursion. The factorial is the product of all positive integers less than or equal to `n`.
              For example, <code>5! = 5 * 4 * 3 * 2 * 1 = 120</code>. By definition, <code>0! = 1</code>.
            </p>
            <p>We can define factorial recursively as follows:</p>
            <ul>
              <li>
                <strong>Base Case:</strong> If <code>n</code> is 0 (or 1, as 1! is also 1), the factorial is 1. So, <code>factorial(0) = 1</code>.
              </li>
              <li>
                <strong>Recursive Step:</strong> If <code>n</code> is greater than 0, the factorial of <code>n</code> is <code>n</code> multiplied by the factorial of <code>(n-1)</code>. So, <code>factorial(n) = n * factorial(n-1)</code> for <code>n > 0</code>.
              </li>
            </ul>
            <pre><code class="code-block-8bit python">def factorial(n):
  print(f"Function call: factorial({n})")
  # Base Case: Stop the recursion
  if n == 0:
    print(f"  Base case reached for factorial(0). Returning 1.")
    return 1
  # Recursive Step: Call the function with a smaller value
  else:
    print(f"  Recursive step for factorial({n}). Needs factorial({n-1})...")
    recursive_result = factorial(n - 1) # Function calls itself
    result = n * recursive_result
    print(f"  Returning from factorial({n}): calculated {n} * {recursive_result} = {result}")
    return result

# Example call to demonstrate the flow
print("Calculating factorial of 3:")
final_answer = factorial(3)
print(f"\nFinal Answer for 3!: {final_answer}")

# Expected Output (illustrative):
# Calculating factorial of 3:
# Function call: factorial(3)
#   Recursive step for factorial(3). Needs factorial(2)...
# Function call: factorial(2)
#   Recursive step for factorial(2). Needs factorial(1)...
# Function call: factorial(1)
#   Recursive step for factorial(1). Needs factorial(0)...
# Function call: factorial(0)
#   Base case reached for factorial(0). Returning 1.
#   Returning from factorial(1): calculated 1 * 1 = 1
#   Returning from factorial(2): calculated 2 * 1 = 2
#   Returning from factorial(3): calculated 3 * 2 = 6
# 
# Final Answer for 3!: 6</code></pre>
            <div class="message-box-8bit error">
              <strong>Crucial Point:</strong> A recursive function MUST have a correctly defined base case. Without it, or if the recursive calls don't eventually reach a base case, the function would call itself infinitely (or until system resources are exhausted), leading to a "stack overflow" error.
            </div>
          </div>
        </section>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            3. How Recursion Works: The Call Stack
          </h2>
          <div class="sub-interactive-box">
            <p>
              When any function calls another function (including when a recursive function calls itself), the computer system uses a special memory area called the <strong>call stack</strong> to keep track of these calls. The call stack manages the order of function execution and the local state of each function call.
            </p>
            <p>Here's how it works in the context of recursion:</p>
            <ul>
              <li>
                <strong>Pushing to the Stack:</strong> Each time a function is called, a new "stack frame" (or "activation record") is created and pushed onto the top of the call stack. This frame contains information specific to that particular call, such as its parameters, local variables, and the point in the code to return to after the function finishes.
                For <code>factorial(3)</code>, a frame for <code>factorial(3)</code> is pushed. Then <code>factorial(3)</code> calls <code>factorial(2)</code>, so a frame for <code>factorial(2)</code> is pushed on top, and so on, until <code>factorial(0)</code>.
              </li>
              <li>
                <strong>Reaching the Base Case:</strong> When a recursive call reaches a base case (e.g., <code>factorial(0)</code>), it computes its result and returns.
              </li>
              <li>
                <strong>Popping from the Stack (Unwinding):</strong> When a function returns, its stack frame is removed (popped) from the top of the call stack. The returned value is then passed back to the caller function (the one whose frame is now at the top of the stack). This caller function can then use this returned value to complete its own computation.
                So, <code>factorial(0)</code> returns 1 to <code>factorial(1)</code>. <code>factorial(1)</code> computes <code>1*1=1</code> and returns 1 to <code>factorial(2)</code>. <code>factorial(2)</code> computes <code>2*1=2</code> and returns 2 to <code>factorial(3)</code>. Finally, <code>factorial(3)</code> computes <code>3*2=6</code> and returns 6 to the original caller.
              </li>
              <li>
                This process of returning values and popping frames is often called "unwinding" the stack.
              </li>
            </ul>
            <p>
              Visualizing this stack of function calls growing and shrinking is key to understanding how recursion progresses and eventually terminates to produce the final result.
            </p>
          </div>
        </section>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            4. Interactive Factorial Visualization
          </h2>
          <div class="sub-interactive-box">
            <p>
              Enter a small non-negative integer (e.g., 0-12, as larger numbers create many calls) to see the factorial calculation steps and a simplified call stack trace.
            </p>
            <div class="controls-flex">
              <label for="factorialInput">Number (n):</label>
              <input
                type="number"
                id="factorialInput"
                class="input-field-8bit"
                min="0"
                max="12"
                value="4"
              />
              <button id="calculateFactorialButton" class="button-8bit">
                Calculate & Visualize
              </button>
            </div>
            <div class="grid-cols-2-responsive mt-4">
              <div>
                <h3 class="section-subtitle-8bit smaller-subtitle">Call Stack Trace:</h3>
                <div id="callStackOutput" class="output-display-8bit min-h-[200px]"><p><em>Call stack events will appear here.</em></p></div>
              </div>
              <div>
                <h3 class="section-subtitle-8bit smaller-subtitle">Calculation Steps:</h3>
                <div id="calculationStepsOutput" class="output-display-8bit min-h-[200px]"><p><em>Calculation details will appear here.</em></p></div>
              </div>
            </div>
            <p class="mt-4">
                <strong>Final Result for n!: <span id="finalResult" class="final-result-text">N/A</span></strong>
            </p>
          </div>
        </section>

        <section class="interactive-section">
            <h2 class="section-subtitle-8bit">
                5. When to Use Recursion (and When Not To)
            </h2>
            <div class="sub-interactive-box">
                <p>Recursion can be an elegant and intuitive solution for problems that have a naturally recursive structure:</p>
                <ul>
                    <li><strong>Tree and Graph Traversals:</strong> Algorithms like Depth-First Search (DFS) for exploring tree or graph nodes are often implemented recursively (e.g., finding files in a directory structure).</li>
                    <li><strong>Divide and Conquer Algorithms:</strong> Many efficient algorithms, such as Merge Sort and Quick Sort, break the problem into smaller subproblems, solve them recursively, and then combine the results.</li>
                    <li><strong>Mathematical Problems Defined Recursively:</strong> Problems like the Fibonacci sequence (<code>F(n) = F(n-1) + F(n-2)</code>) or factorial (<code>n! = n * (n-1)!</code>) have direct recursive definitions.</li>
                    <li><strong>Parsing Hierarchical Data:</strong> Structures like JSON or XML can be parsed recursively, though often, dedicated libraries handle this complexity.</li>
                </ul>
                <p>However, recursion is not always the optimal choice and has potential drawbacks:</p>
                <ul>
                    <li><strong>Performance Overhead:</strong> Each function call incurs some overhead (e.g., creating a stack frame, passing parameters). For simple iterative problems (like summing elements in a list), a straightforward loop is usually faster and more memory-efficient.</li>
                    <li><strong>Stack Overflow Risk:</strong> If the recursion is too deep (i.e., too many nested calls without reaching a base case quickly enough), it can exhaust the available space on the call stack, leading to a stack overflow error. This is particularly a concern for problems that might lead to very long chains of recursion. Python has a default recursion limit (which can be checked with <code>sys.getrecursionlimit()</code> and modified with <code>sys.setrecursionlimit()</code>), but relying on increasing this limit is often a sign that an iterative approach might be better suited if the depth is an issue for typical inputs.</li>
                    <li><strong>Readability and Debugging:</strong> While recursion can be very clear for problems that map directly to a recursive definition, complex recursive logic can sometimes be harder to understand, follow, and debug than an equivalent iterative solution, especially for those less familiar with the concept.</li>
                </ul>
                <div class="message-box-8bit info">
                    It's important to note that any problem solvable with recursion can also be solved using iteration (loops), though the iterative solution might require an explicit data structure (like a stack) to mimic the behavior of the call stack. The choice between recursion and iteration often depends on factors like the clarity of the solution for the specific problem, efficiency considerations, and the potential for stack overflow issues with the expected input sizes.
                </div>
            </div>
        </section>
      </main>

      <footer class="footer-8bit text-center py-6">
        <p class="text-md md:text-lg">Happy Coding, Player 1!</p>
        <p class="mt-3 md:mt-4">
          <a
            href="../index.html"
            class="link-8bit"
            >Back to Main Menu</a>
        </p>
      </footer>
    </div> <!-- End of console-screen-border -->

    <script>
        const factorialInput = document.getElementById('factorialInput');
        const calculateFactorialButton = document.getElementById('calculateFactorialButton');
        const callStackOutput = document.getElementById('callStackOutput');
        const calculationStepsOutput = document.getElementById('calculationStepsOutput');
        const finalResultSpan = document.getElementById('finalResult');

        let callStackDepth = 0;

        function logToCallStack(message, type = 'call') {
            const p = document.createElement('p');
            let prefix = '';
            if (type === 'call') {
                prefix = `&rarr; Call (${callStackDepth}): `;
            } else if (type === 'return') {
                prefix = `&larr; Return (${callStackDepth}): `;
            }
            p.innerHTML = `${'&nbsp;'.repeat(callStackDepth * 2)}${prefix}${message}`;
            callStackOutput.appendChild(p);
            callStackOutput.scrollTop = callStackOutput.scrollHeight;
        }

        function logToCalculation(message) {
            const p = document.createElement('p');
            p.innerHTML = `${'&nbsp;'.repeat(callStackDepth * 2)}${message}`;
            calculationStepsOutput.appendChild(p);
            calculationStepsOutput.scrollTop = calculationStepsOutput.scrollHeight;
        }

        function factorialVisualize(n) {
            callStackDepth++;
            logToCallStack(`factorial(${n}) invoked.`);

            if (n < 0) {
                logToCalculation(`Error: Factorial is not defined for negative numbers.`);
                logToCallStack(`factorial(${n}) returning error.`, 'return');
                callStackDepth--;
                throw new Error("Factorial not defined for negative numbers");
            }
            if (n > 12) { // Limit to prevent browser slowdown / too much output
                logToCalculation(`Input ${n} is too large for visualization. Max is 12.`);
                 logToCallStack(`factorial(${n}) stopping due to large input.`, 'return');
                callStackDepth--;
                throw new Error("Input too large for visualization.");
            }

            // Base Case
            if (n === 0) {
                logToCalculation(`Base Case: factorial(0) = 1.`);
                logToCallStack(`factorial(0) returns 1.`, 'return');
                callStackDepth--;
                return 1;
            }
            // Recursive Step
            else {
                logToCalculation(`Recursive Step: factorial(${n}) = ${n} * factorial(${n - 1})`);
                const recursiveResult = factorialVisualize(n - 1);
                const result = n * recursiveResult;
                logToCalculation(`Calculation: factorial(${n}) = ${n} * ${recursiveResult} = ${result}`);
                logToCallStack(`factorial(${n}) returns ${result}.`, 'return');
                callStackDepth--;
                return result;
            }
        }

        calculateFactorialButton.addEventListener('click', () => {
            callStackOutput.innerHTML = '';
            calculationStepsOutput.innerHTML = '';
            finalResultSpan.textContent = 'N/A';
            callStackDepth = 0;

            const num = parseInt(factorialInput.value);

            if (isNaN(num)) {
                calculationStepsOutput.innerHTML = '<p>Please enter a valid number.</p>';
                return;
            }

            try {
                logToCallStack(`--- Starting factorial(${num}) visualization ---`);
                const result = factorialVisualize(num);
                finalResultSpan.textContent = result;
                logToCallStack(`--- Visualization complete for factorial(${num}) ---`, 'complete');
            } catch (error) {
                finalResultSpan.textContent = 'Error';
                // Error already logged in calculation/stack trace by the recursive function
                logToCallStack(`--- Visualization stopped due to error for factorial(${num}) ---`, 'error');
            }
        });

        // Initial placeholder messages
        callStackOutput.innerHTML = '<p><em>Call stack events will appear here. Click \'Calculate & Visualize\'.</em></p>';
        calculationStepsOutput.innerHTML = '<p><em>Calculation details will appear here. Click \'Calculate & Visualize\'.</em></p>';
    </script>
  </body>
</html>
