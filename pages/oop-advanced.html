<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced OOP - Python Guide</title>
    <!-- <script src="https://cdn.tailwindcss.com"></script> -->
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/shared-styles.css">
  </head>
  <body class="min-h-screen">
    <div class="console-screen-border">
      <header class="text-center mb-12 md:mb-16">
        <h1 class="pixel-header">
          Interactive Python Guide
        </h1>
        <p class="pixel-subheader mt-4">
          Retro Journey into Code!
        </p>
      </header>

      <main class="mx-auto">
        <h1 class="page-title-8bit">
          Advanced OOP Concepts
        </h1>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            1. Inheritance: Reusing Code
          </h2>
          <div class="sub-interactive-box">
            <p>
              Inheritance is a fundamental concept in Object-Oriented Programming (OOP) that allows a new class (called a <strong>subclass</strong> or <strong>derived class</strong>) to acquire the properties (attributes) and behaviors (methods) of an existing class (called a <strong>superclass</strong> or <strong>base class</strong>). This establishes an "is-a" hierarchical relationship (e.g., a `Dog` is an `Animal`, a `Warrior` is a `Character`). The primary benefit of inheritance is code reusability and the creation of a logical structure.
            </p>
            <p>
              Subclasses can directly use the inherited attributes and methods. They can also add new, specific attributes and methods, or even modify (<strong>override</strong>) inherited methods to provide a more specialized behavior. The <code>super()</code> function is often used within a subclass to call methods of its superclass, especially the <code>__init__()</code> constructor.
            </p>
            <pre><code class="code-block-8bit python"># Superclass (Base Class)
class Character:
  def __init__(self, name, health=100):
    self.name = name
    self.health = health
    print(f"Character '{self.name}' emerges with {self.health} HP.")

  def attack(self, target):
    print(f"{self.name} performs a generic attack on {target.name}.")

  def show_status(self):
    print(f"{self.name} - Health: {self.health}")

# Subclass (Derived Class) - inherits from Character
class Warrior(Character):
  def __init__(self, name, health=150, weapon="Sword"):
    super().__init__(name, health) # Initialize the Character part
    self.weapon = weapon
    print(f"They are a Warrior, wielding a mighty {self.weapon}!")

  # Override the attack method for specialized behavior
  def attack(self, target):
    print(f"{self.name} charges at {target.name} with their {self.weapon}! SWOOSH!")
    # Warriors might do specific damage, etc.

  # Add a new method specific to Warrior
  def use_shield_bash(self, target):
    print(f"{self.name} bashes {target.name} with their shield! THUD!")

# --- Example Usage ---
hero_pixelot = Warrior("Sir Pixelot", 120, "Pixel Blade")
# Output:
# Character 'Sir Pixelot' emerges with 120 HP.
# They are a Warrior, wielding a mighty Pixel Blade!

goblin_grunt = Character("Goblin Grunt", 50)
# Output:
# Character 'Goblin Grunt' emerges with 50 HP.

hero_pixelot.show_status()
# Output: Sir Pixelot - Health: 120

goblin_grunt.show_status()
# Output: Goblin Grunt - Health: 50

hero_pixelot.attack(goblin_grunt) # Calls Warrior's overridden attack method
# Output: Sir Pixelot charges at Goblin Grunt with their Pixel Blade! SWOOSH!

goblin_grunt.attack(hero_pixelot) # Calls Character's generic attack method
# Output: Goblin Grunt performs a generic attack on Sir Pixelot.

hero_pixelot.use_shield_bash(goblin_grunt) # Calls Warrior-specific method
# Output: Sir Pixelot bashes Goblin Grunt with their shield! THUD!</code></pre>
          </div>
        </section>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            2. Encapsulation: Bundling and Hiding
          </h2>
          <div class="sub-interactive-box">
            <p>
              Encapsulation is the OOP principle of bundling data (attributes) and the methods that operate on that data within a single unit, i.e., an object. A key aspect of encapsulation is <strong>information hiding</strong>, which means restricting direct access to some of an object's internal state or components. This protects the object's integrity and allows the internal implementation to be changed without affecting external code that uses the object.
            </p>
            <p>
              In Python, there isn't true "private" in the sense of some other languages (like Java or C++). Instead, Python uses naming conventions to indicate the intended visibility of attributes and methods:
            </p>
            <ul>
              <li><strong>Single Underscore Prefix (e.g., <code>_attribute</code>):</strong> This is a convention indicating that the attribute or method is intended for internal use within the class or by subclasses. It's a hint to developers not to access it directly from outside the class, but it's still accessible.</li>
              <li><strong>Double Underscore Prefix (e.g., <code>__attribute</code>):</strong> This triggers name mangling. Python changes the name to <code>_ClassName__attribute</code>. This makes it harder to access directly from outside the class, providing a stronger (but still not absolute) form of privacy. It's primarily used to avoid naming conflicts in subclasses.</li>
            </ul>
            <p>
              To provide controlled access to an object's data, public methods (often called getters and setters, or accessor and mutator methods) are typically provided.
            </p>
            <pre><code class="code-block-8bit python">class TreasureChest:
  def __init__(self, initial_gold=0):
    self._gold_coins = initial_gold  # Intended for internal use
    self.__secret_item = "Map to Hidden Glade" # Name-mangled attribute
    self._is_locked = True

  def add_gold(self, amount):
    if not self._is_locked and amount > 0:
      self._gold_coins += amount
      print(f"Added {amount} gold. Total: {self._gold_coins} coins.")
    elif self._is_locked:
      print("The chest is locked! Cannot add gold.")
    else:
      print("Amount must be positive.")

  def get_gold_count(self):
    if not self._is_locked:
      return self._gold_coins
    else:
      print("The chest is locked! Cannot see gold count.")
      return 0
  
  def unlock_chest(self, key):
    if key == "PixelKey123":
      self._is_locked = False
      print("Chest unlocked!")
    else:
      print("Wrong key!")

  def lock_chest(self):
    self._is_locked = True
    print("Chest locked.")

  # Method to access the name-mangled attribute indirectly
  def reveal_secret_item_if_unlocked(self):
      if not self._is_locked:
          print(f"Secret item found: {self.__secret_item}")
      else:
          print("Unlock the chest to reveal secrets!")

# --- Example Usage ---
my_chest = TreasureChest(100)

print(f"Gold: {my_chest.get_gold_count()}") # Chest is locked!
my_chest.add_gold(50) # Chest is locked!

my_chest.unlock_chest("PixelKey123") # Chest unlocked!
print(f"Gold: {my_chest.get_gold_count()}") # Output: 100
my_chest.add_gold(50) # Added 50 gold. Total: 150 coins.

my_chest.reveal_secret_item_if_unlocked()
# Output: Secret item found: Map to Hidden Glade

my_chest.lock_chest() # Chest locked.
# Direct access to _gold_coins is possible but discouraged:
# print(my_chest._gold_coins) 

# Direct access to __secret_item will fail due to name mangling:
# print(my_chest.__secret_item) # AttributeError
# Access via mangled name (don't do this in practice):
# print(my_chest._TreasureChest__secret_item)</code></pre>
          </div>
        </section>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            3. Polymorphism: Many Forms
          </h2>
          <div class="sub-interactive-box">
            <p>
              Polymorphism, meaning "many forms," is an OOP concept that allows objects of different classes to be treated as objects of a common superclass. It typically manifests through method overriding, where different subclasses provide their specific implementations of a method defined in their superclass. When you call this method on an object, Python automatically executes the version of the method that is appropriate for the object's actual class.
            </p>
            <p>
              This enables you to write more generic and flexible code. For instance, you can have a list of objects from different subclasses of a common parent and call the same method on each object, with each object responding in its own unique way.
            </p>
            <pre><code class="code-block-8bit python">class GameEntity:
  def __init__(self, name):
    self.name = name
  
  def interact(self):
    # Default interaction
    print(f"The {self.name} just sits there, an enigmatic presence.")

class PlayerCharacter(GameEntity):
  def interact(self):
    # Player-specific interaction
    print(f"'{self.name}' the Player exclaims: \"Greetings, world! Time for adventure!\"")

class NonPlayerCharacter(GameEntity):
  def __init__(self, name, dialogue="..."):
    super().__init__(name)
    self.dialogue = dialogue

  def interact(self):
    # NPC-specific interaction
    print(f"'{self.name}' the Villager says: \"{self.dialogue}\"")

class InteractiveScenery(GameEntity):
  def __init__(self, name, description="It's part of the background."):
    super().__init__(name)
    self.description = description
  
  def interact(self):
    # Scenery-specific interaction
    print(f"Upon interacting with the {self.name}: {self.description}")

# --- Example Usage: Polymorphism in Action ---
world_entities = [
    PlayerCharacter("Sir Kodington"), 
    NonPlayerCharacter("Old Man Willow", dialogue="The forest remembers ancient secrets..."), 
    InteractiveScenery("Mystic Shrine", description="A faint hum emanates from it."),
    GameEntity("Generic Rock") # Uses base class interact method
]

print("--- World Interactions ---")
for entity in world_entities:
  entity.interact() # Calls the specific interact() of each object's class

# Expected Output:
# --- World Interactions ---
# 'Sir Kodington' the Player exclaims: "Greetings, world! Time for adventure!"
# 'Old Man Willow' the Villager says: "The forest remembers ancient secrets..."
# Upon interacting with the Mystic Shrine: A faint hum emanates from it.
# The Generic Rock just sits there, an enigmatic presence.</code></pre>
            <div id="polymorphismDemoContainer" class="mt-4">
              <h3 class="section-subtitle-8bit smaller-subtitle">JavaScript Polymorphism Demo:</h3>
              <button id="runPolyDemoButton" class="button-8bit">Run JS Demo</button>
              <div id="polyOutput" class="output-display-8bit min-h-[100px] mt-2">
                <p><em>Click button to see JavaScript polymorphism in action.</em></p>
              </div>
            </div>
          </div>
        </section>
      </main>

      <footer class="footer-8bit text-center py-6">
        <p class="text-md md:text-lg">Happy Coding, Player 1!</p>
        <p class="mt-3 md:mt-4">
          <a
            href="../index.html" 
            class="link-8bit" 
            >Back to Main Menu</a 
          >
        </p>
      </footer>
    </div> <!-- End of console-screen-border -->

    <script>
      // Polymorphism Demo Script (JavaScript)
      const runPolyDemoButton = document.getElementById('runPolyDemoButton');
      const polyOutputDiv = document.getElementById('polyOutput');

      // Base class
      class JSEntity {
          constructor(name) {
              this.name = name;
          }
          interact() {
              return `The ${this.name} (JS Entity) does a generic JavaScript thing.`;
          }
      }

      // Derived class 1
      class JSWizard extends JSEntity {
          interact() {
              return `<b>${this.name} the JS Wizard</b> chants: \"DOM-manipulum!\" The page shimmers.`;
          }
      }

      // Derived class 2
      class JSMonster extends JSEntity {
        constructor(name, sound = "ROAR") {
            super(name);
            this.sound = sound;
        }
          interact() {
              return `<b>${this.name} the JS Monster</b> lets out a ${this.sound.toUpperCase()}! The console trembles.`;
          }
      }
      
      // Derived class 3
       class JSItem extends JSEntity {
        constructor(name, effect = "glows faintly") {
            super(name);
            this.effect = effect;
        }
          interact() {
              return `<b>${this.name} the JS Item</b> ${this.effect}.`;
          }
      }

      runPolyDemoButton.addEventListener('click', () => {
          polyOutputDiv.innerHTML = ''; // Clear previous output

          const entities = [
              new JSWizard("MerlinScript"),
              new JSMonster("Bugzilla", "grrrRRR"),
              new JSItem("Orb of Power", "pulses with arcane energy"),
              new JSEntity("Plain Div")
          ];

          entities.forEach(entity => {
              const p = document.createElement('p');
              p.innerHTML = entity.interact(); // Polymorphic call!
              polyOutputDiv.appendChild(p);
          });
          polyOutputDiv.scrollTop = polyOutputDiv.scrollHeight;
      });

      // Set initial message for poly output
      if (polyOutputDiv.children.length === 1 && polyOutputDiv.firstElementChild.tagName === 'P' && polyOutputDiv.firstElementChild.children.length === 1 && polyOutputDiv.firstElementChild.firstElementChild.tagName === 'EM') {
        // Already has initial message, do nothing or ensure it's the correct one
      } else {
        polyOutputDiv.innerHTML = '<p><em>Click button to see JavaScript polymorphism in action.</em></p>';
      }
    </script>
  </body>
</html>
