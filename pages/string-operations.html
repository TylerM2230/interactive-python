<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>String Operations in Python</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/shared-styles.css">
  </head>
  <body class="">
    <div class="console-screen-border">
      <nav class="navbar-8bit">
        <a href="../index.html" class="btn">
          &laquo; Main Menu
        </a>
        <a href="functions.html" class="btn">
          Next: Functions &rarr;
        </a>
      </nav>

      <div class="content-wrapper-8bit">
        <header class="text-center mb-8">
          <h1 class="pixel-header"><a href="../index.html">
            Interactive Guide to Python
          </a></h1>
          <h2 class="pixel-subheader">
            String Operations
          </h2>
          <p class="text-sm italic mt-1">
            Manipulating text data using various built-in methods for formatting, searching, and modification.
          </p>
        </header>

        <section class="game-section">
          <h2 class="section-title-8bit">
            1. What are Strings?
          </h2>
          <p class="mb-4">
            A string is like a necklace of beads - each character is a bead, and they're strung together in a specific order. Just as you can't change a bead's position without making a new necklace, strings in Python are **immutable** - you can't change individual characters directly. Instead, you create a new string with the changes you want. Think of it like a sentence written in ink - you can't erase or change individual letters, but you can write a new sentence with the changes you want.
          </p>
          <p class="mb-2">
            You can create strings using different types of quotes, just like how you might use different types of containers for different purposes:
            <ul class="list-disc list-inside ml-4 mt-2">
              <li>Single quotes (<code>'...'</code>) are like a small box - good for short strings, similar to how you might use a small container for a single item</li>
              <li>Double quotes (<code>"..."</code>) are like a medium box - good for strings with single quotes inside, like a container that can hold other containers</li>
              <li>Triple quotes (<code>'''...'''</code> or <code>"""..."""</code>) are like a large box - perfect for multi-line strings, similar to how you might use a large container for multiple items or a complex arrangement</li>
            </ul>
          </p>
          <pre><code class="language-python">greeting = "Hello, Python!"  # Using double quotes
name = 'Alice'            # Using single quotes
empty_string = ""
multiline_string = """
This is a
multi-line string.
"""

print(greeting)
print(type(name)) # Output: <class 'str'>
print(multiline_string)</code></pre>
        </section>

        <section class="game-section interactive-section">
          <h2 class="section-title-8bit">
            2. Combining & Repeating Strings
          </h2>
          <p class="mb-2">
            Working with strings is like playing with building blocks. You can:
            <ul class="list-disc list-inside ml-4 mt-2">
              <li>Combine strings using <code>+</code> - like connecting two train cars or linking together pieces of a chain</li>
              <li>Repeat strings using <code>*</code> - like making multiple copies of the same pattern, similar to how a printer can make multiple copies of a document</li>
              <li>Mix strings with other types using <code>str()</code> - like converting different types of blocks to fit together, similar to how you might need to convert different types of materials to work together in a construction project</li>
            </ul>
          </p>
          <pre><code class="language-python">first_name = "Ada"
last_name = "Lovelace"

# Concatenation
full_name = first_name + " " + last_name
print(full_name)  # Output: Ada Lovelace

# Repetition
separator = "-" * 10
print(separator)  # Output: ----------

# Combining with other types (requires conversion to string)
age = 30
# print("Age: " + age) # This would cause a TypeError
print("Age: " + str(age)) # Correct: Age: 30
print(f"Age: {age}")      # Using an f-string (preferred for readability)</code></pre>

          <h3 class="text-lg font-medium text-cyan-400 mt-4 mb-2">Try it:</h3>
          <div class="flex flex-wrap items-center mb-2">
            <input
              type="text"
              id="str1Input"
              class="input-field"
              placeholder="String 1"
              value="Hello"
            />
            <span class="mx-2 text-xl font-bold">+</span>
            <input
              type="text"
              id="str2Input"
              class="input-field"
              placeholder="String 2"
              value=" World"
            />
            <button id="concatButton" class="btn">Concatenate</button>
          </div>
          <div class="flex flex-wrap items-center mb-2">
            <input
              type="text"
              id="strRepeatInput"
              class="input-field"
              placeholder="String to Repeat"
              value="Go "
            />
            <span class="mx-2 text-xl font-bold">*</span>
            <input
              type="number"
              id="repeatNumInput"
              class="input-field input-field-small"
              placeholder="Num"
              value="3"
              min="0"
            />
            <button id="repeatButton" class="btn">Repeat</button>
          </div>
          <h4 class="text-md font-medium mt-3 mb-1">Result:</h4>
          <div id="combineResultDisplay" class="output-display">
            <span class="text-gray-500 italic"
              >Click buttons above to see results.</span
            >
          </div>
          <div
            id="combineMessage"
            class="message-box"
            style="display: none"
          ></div>
        </section>

        <section class="game-section interactive-section">
          <h2 class="section-title-8bit">
            3. String Indexing and Slicing
          </h2>
          <p class="mb-2">
            Think of a string as a row of numbered lockers in a school hallway. Each character has its own locker number (index), and you can:
            <ul class="list-disc list-inside ml-4 mt-2">
              <li><strong>Indexing:</strong> Open a specific locker to see what's inside (get a single character), like checking a specific mailbox in a row of mailboxes</li>
              <li><strong>Slicing:</strong> Look at a range of lockers (get a substring), similar to how you might look at a section of books on a bookshelf</li>
            </ul>
            Just like how locker numbers start at 1, but string indices start at 0, and negative numbers count from the end of the hallway! It's similar to how a race car starts at position 0 before crossing the starting line, or how a ruler starts at 0 before measuring the first inch.
          </p>
          <ul class="list-disc list-inside ml-4 space-y-1">
              <li><strong>Indexing:</strong> Access a single character. Python uses 0-based indexing (the first character is at index 0).
                  Negative indexing starts from the end (-1 is the last character).</li>
              <li><strong>Slicing:</strong> Extract a portion of the string. Syntax: <code>my_string[start:stop:step]</code>.
                  <ul>
                      <li><code>start</code>: The index to begin the slice (inclusive). Defaults to 0.</li>
                      <li><code>stop</code>: The index to end the slice (exclusive). Defaults to the end of the string.</li>
                      <li><code>step</code>: The amount to increment by (e.g., 2 for every other character). Defaults to 1.</li>
                  </ul>
              </li>
          </ul>
          <pre><code class="language-python">text = "Python Fun"
# Indexing
print(f"First char: {text[0]}")   # Output: P
print(f"Last char: {text[-1]}")  # Output: n
# print(text[10]) # IndexError: string index out of range

# Slicing
print(f"Slice [0:6]: {text[0:6]}") # Output: Python
print(f"Slice [:6]: {text[:6]}")   # Output: Python (from start up to, not including, index 6)
print(f"Slice [7:]: {text[7:]}")   # Output: Fun (from index 7 to the end)
print(f"Slice [::-1]: {text[::-1]}") # Output: nuF nohtyP (reverses the string)
print(f"Slice [::2]: {text[::2]}")  # Output: Pto u (every other character)
</code></pre>
        </section>

        <section class="game-section interactive-section">
          <h2 class="section-title-8bit">
            Interactive String Indexing & Slicing
          </h2>
          <p class="mb-4">
            Enter a string and indices to see indexing and slicing in action.
            The example string is "PixelWorld".
          </p>
          <div id="accessStringVis" class="string-vis-container mb-4"></div>
          <div class="flex flex-wrap items-center mb-2">
            <label for="accessIndexInput" class="mr-2">Index:</label>
            <input
              type="number"
              id="accessIndexInput"
              class="input-field input-field-small"
              placeholder="e.g., 0, -1"
            />
            <button id="accessIndexButton" class="btn">Get Character</button>
          </div>
          <div class="flex flex-wrap items-center mb-2">
            <label for="sliceStartInput" class="mr-2">Slice Start:</label>
            <input
              type="number"
              id="sliceStartInput"
              class="input-field input-field-small"
              placeholder="Start"
            />
            <label for="sliceStopInput" class="ml-4 mr-2">Stop:</label>
            <input
              type="number"
              id="sliceStopInput"
              class="input-field input-field-small"
              placeholder="Stop"
            />
            <label for="sliceStepInput" class="ml-4 mr-2">Step:</label>
            <input
              type="number"
              id="sliceStepInput"
              class="input-field input-field-small"
              placeholder="Step"
            />
            <button id="sliceButton" class="btn">Get Slice</button>
          </div>
          <h4 class="text-md font-medium mt-3 mb-1">Result:</h4>
          <div id="accessResultDisplay" class="output-display">
            <span class="text-gray-500 italic"
              >Enter index/slice values and click buttons.</span
            >
          </div>
          <div
            id="accessStrMessage"
            class="message-box"
            style="display: none"
          ></div>
        </section>

        <section class="game-section">
          <h2 class="section-title-8bit">
            4. Common String Methods
          </h2>
          <p class="mb-2">
            String methods are like tools in a toolbox - each one has a specific purpose for working with text. Remember, since strings are immutable, these methods don't change the original string - they create a new one, like making a copy of a document before editing it.
          </p>
          <ul class="list-disc list-inside ml-4 space-y-1 text-sm">
            <li><code>len(my_string)</code>: Like counting how many beads are on your necklace</li>
            <li><code>.lower()</code>: Like turning all the lights in a room to their dimmest setting</li>
            <li><code>.upper()</code>: Like turning all the lights to their brightest setting</li>
            <li><code>.strip()</code>: Like trimming the edges of a piece of paper to remove any uneven bits</li>
            <li><code>.replace(old, new)</code>: Like finding and replacing all instances of a word in a document</li>
            <li><code>.split(separator)</code>: Like cutting a piece of string at specific points to create smaller pieces</li>
            <li><code>.join(iterable)</code>: Joins elements of an iterable (like a list of strings) into a single string, with the original string as a separator.</li>
            <li><code>.startswith(prefix)</code>: Returns <code>True</code> if the string starts with <code>prefix</code>.</li>
            <li><code>.endswith(suffix)</code>: Returns <code>True</code> if the string ends with <code>suffix</code>.</li>
            <li><code>.find(substring)</code>: Returns the starting index of the first occurrence of <code>substring</code>. Returns -1 if not found. <code>.rfind()</code> finds from the right.</li>
            <li><code>.count(substring)</code>: Returns the number of non-overlapping occurrences of <code>substring</code>.</li>
            <li><code>.isdigit()</code>, <code>.isalpha()</code>, <code>.isalnum()</code>, <code>.isspace()</code>: Check if characters are digits, alphabetic, alphanumeric, or whitespace.</li>
          </ul>
          <pre><code class="language-python">text = "  Hello, Python World!  "

print(f"Length: {len(text)}")
print(f"Lowercase: '{text.lower()}'")
print(f"Uppercase: '{text.upper()}'")
print(f"Stripped: '{text.strip()}'")
print(f"Replaced: '{text.replace("Python", "User")}'")
print(f"Split by ',': {text.split(',')}")

words = ["Python", "is", "fun"]
print(f"Joined: '{'-'.join(words)}'") # Output: Python-is-fun

print(f"Starts with '  H': {text.startswith('  H')}")
print(f"Ends with '!  ': {text.endswith('!  ')}")
print(f"Find 'Python': {text.find('Python')}")
print(f"Count 'o': {text.count('o')}")</code></pre>
        </section>

        <section class="game-section interactive-section">
          <h2 class="section-title-8bit">
            Interactive String Methods
          </h2>
          <p class="mb-4">
            Try some common string methods with your own input string.
          </p>
          <div class="mb-2">
            <label for="methodStrInput" class="block font-medium"
              >Input String:</label
            >
            <input
              type="text"
              id="methodStrInput"
              class="input-field w-full"
              value="  Example String To Test  "
            />
          </div>
          <div class="flex flex-wrap items-center mb-2">
            <label for="methodSelect" class="mr-2">Method:</label>
            <select id="methodSelect" class="select-field">
              <option value="len">len()</option>
              <option value="upper">.upper()</option>
              <option value="lower">.lower()</option>
              <option value="strip">.strip()</option>
              <option value="replace">.replace(old, new)</option>
              <option value="find">.find(substring)</option>
              <option value="split">.split(separator)</option>
            </select>
            <div id="methodArgsContainer" class="inline-block ml-2"></div>
            <button id="applyMethodButton" class="btn btn-green">
              Apply Method
            </button>
          </div>
          <h4 class="text-md font-medium mt-3 mb-1">Result:</h4>
          <div id="methodResultDisplay" class="output-display">
            <span class="text-gray-500 italic"
              >Select a method and click 'Apply'.</span
            >
          </div>
          <div id="methodMessage" class="message-box" style="display: none"></div>
        </section>

        <section class="game-section">
          <h2 class="section-title-8bit">
            5. String Formatting
          </h2>
          <p class="mb-2">
            Often, you need to embed variables or expressions within strings. Python offers several ways to do this:
          </p>
          <ul class="list-disc list-inside ml-4 space-y-1">
              <li><strong>f-strings (Formatted String Literals - Recommended):</strong> Introduced in Python 3.6, f-strings provide a concise and readable way to embed expressions inside string literals. Prefix the string with <code>f</code> or <code>F</code> and enclose expressions in curly braces <code>{}</code>.</li>
              <li><code>.format()</code> method: A versatile method available in older Python versions too. Uses curly braces as placeholders.</li>
              <li>Older <code>%</code> operator (C-style formatting): Less common in modern Python code but you might encounter it.</li>
          </ul>
          <pre><code class="language-python">name = "Alice"
age = 30

# f-string (preferred)
formatted_f = f"My name is {name} and I am {age} years old."
print(formatted_f)

# .format() method
formatted_dot = "My name is {} and I am {} years old.".format(name, age)
print(formatted_dot)

formatted_dot_named = "My name is {n} and I am {a} years old.".format(n=name, a=age)
print(formatted_dot_named)

# % operator (older style)
formatted_percent = "My name is %s and I am %d years old." % (name, age)
print(formatted_percent)</code></pre>
          <p class="mt-2 text-sm text-cyan-300">
              F-strings also support formatting specifiers within the curly braces, e.g., <code>{value:.2f}</code> to format a float to 2 decimal places.
          </p>
        </section>

        <section class="game-section interactive-section">
          <h2 class="section-title-8bit">
            Interactive: String Formatting (f-string)
          </h2>
          <p class="mb-4">Enter a name and an item to create a personalized message using an f-string.</p>
          <div class="mb-2">
            <label for="nameInput" class="block font-medium">Name:</label>
            <input
              type="text"
              id="nameInput"
              class="input-field w-full"
              placeholder="Enter your name"
            />
          </div>
          <div class="mb-2">
            <label for="itemInput" class="block font-medium">Item:</label>
            <input
              type="text"
              id="itemInput"
              class="input-field w-full"
              placeholder="Enter an item"
            />
          </div>
          <button id="formatButton" class="btn">Format</button>
          <h4 class="text-md font-medium mt-3 mb-1">Result:</h4>
          <div id="formattedMessage" class="output-display">
            <span class="text-gray-500 italic"
              >Enter a name and an item to see a personalized message.</span
            >
          </div>
          <div id="formatMessage" class="message-box" style="display: none"></div>
        </section>

        <section class="game-section">
          <h2 class="section-title-8bit">
            6. Escape Characters
          </h2>
          <p class="mb-2">
            Sometimes you need to include characters in a string that have special meaning, like a newline,
            a tab, or a quote character itself. This is done using **escape characters**, which start with a
            backslash <code>\</code>.
          </p>
          <ul class="list-disc list-inside ml-4 space-y-1">
              <li><code>\n</code>: Newline</li>
              <li><code>\t</code>: Tab</li>
              <li><code>\'</code>: Single quote</li>
              <li><code>\"</code>: Double quote</li>
              <li><code>\\</code>: Backslash</li>
          </ul>
          <pre><code class="language-python">print("This is line one.\nThis is line two.")
# Output:
# This is line one.
# This is line two.

print("She said: \"Hello!\"") # Output: She said: "Hello!"
print('It\'s a sunny day.') # Output: It's a sunny day.
print("Path: C:\\Users\\Name") # Output: Path: C:\Users\Name</code></pre>
          <h3 class="text-lg font-medium text-cyan-400 mt-4 mb-1">Raw Strings:</h3>
          <p class="mb-2">
            If you have many backslashes (e.g., in file paths or regular expressions), you can use a
            <strong>raw string</strong> by prefixing the string literal with <code>r</code>. In raw strings,
            backslashes are treated as literal characters.
          </p>
          <pre><code class="language-python"># Regular string, needs double backslashes for path
path1 = "C:\\new_folder\\text_file.txt"
print(f"Regular path: {path1}")

# Raw string, backslashes are literal
path2 = r"C:\new_folder\text_file.txt"
print(f"Raw path: {path2}")
# Note: A raw string cannot end in an odd number of backslashes.</code></pre>
        </section>

        <section class="game-section interactive-section">
          <h2 class="section-title-8bit">
            8. Quick Quiz
          </h2>
          <p class="mb-4">Test your understanding!</p>
          <div class="mb-3">
            <p class="font-medium mb-1">
              Q1: Which operator is used for string concatenation in Python?
            </p>
            <label class="block p-2 border border-yellow-500 rounded-md hover:bg-blue-900 cursor-pointer"
              ><input type="radio" name="q1_str" value="a" class="mr-1" />
              <code>&</code></label
            >
            <label class="block p-2 border border-yellow-500 rounded-md hover:bg-blue-900 cursor-pointer"
              ><input type="radio" name="q1_str" value="b" class="mr-1" />
              <code>+</code></label
            >
            <label class="block p-2 border border-yellow-500 rounded-md hover:bg-blue-900 cursor-pointer"
              ><input type="radio" name="q1_str" value="c" class="mr-1" />
              <code>.concat()</code></label
            >
          </div>
          <div class="mb-3">
            <p class="font-medium mb-1">
              Q2: Which of the following is the correct way to access the first character of a string?
            </p>
            <label class="block p-2 border border-yellow-500 rounded-md hover:bg-blue-900 cursor-pointer"
              ><input type="radio" name="q2_str" value="a" class="mr-1" />
              <code>my_string[0]</code></label
            >
            <label class="block p-2 border border-yellow-500 rounded-md hover:bg-blue-900 cursor-pointer"
              ><input type="radio" name="q2_str" value="b" class="mr-1" />
              <code>my_string.first()</code></label
            >
            <label class="block p-2 border border-yellow-500 rounded-md hover:bg-blue-900 cursor-pointer"
              ><input type="radio" name="q2_str" value="c" class="mr-1" />
              <code>my_string(0)</code></label
            >
          </div>
          <div class="mb-3">
            <p class="font-medium mb-1">
              Q3: Which of the following is true about the .upper() method?
            </p>
            <label class="block p-2 border border-yellow-500 rounded-md hover:bg-blue-900 cursor-pointer"
              ><input type="radio" name="q3_str" value="a" class="mr-1" /> It
              modifies the original string to be all uppercase.</label
            >
            <label class="block p-2 border border-yellow-500 rounded-md hover:bg-blue-900 cursor-pointer"
              ><input type="radio" name="q3_str" value="b" class="mr-1" /> It
              returns a new string with all characters in uppercase.</label
            >
            <label class="block p-2 border border-yellow-500 rounded-md hover:bg-blue-900 cursor-pointer"
              ><input type="radio" name="q3_str" value="c" class="mr-1" /> It
              checks if the string is already uppercase.</label
            >
          </div>
          <div class="mb-3">
            <p class="font-medium mb-1">
              Q4: Which of the following is the correct way to format a string with variables?
            </p>
            <label class="block p-2 border border-yellow-500 rounded-md hover:bg-blue-900 cursor-pointer"
              ><input type="radio" name="q4_str" value="a" class="mr-1" />
              <code>print("Name: " + name + ", Age: " + age)</code></label
            >
            <label class="block p-2 border border-yellow-500 rounded-md hover:bg-blue-900 cursor-pointer"
              ><input type="radio" name="q4_str" value="b" class="mr-1" />
              <code>print(f"Name: {name}, Age: {age}")</code></f-string></label
            >
            <label class="block p-2 border border-yellow-500 rounded-md hover:bg-blue-900 cursor-pointer"
              ><input type="radio" name="q4_str" value="c" class="mr-1" />
              <code>print("Name: {0}, Age: {1}".format(name, age))</code></f-string></label
            >
            <label class="block p-2 border border-yellow-500 rounded-md hover:bg-blue-900 cursor-pointer">
              <input type="radio" name="q4_str" value="d" class="mr-1" />
              Both b and c are recommended and correct ways.</label>
          </div>
          <button id="checkQuizButtonStr" class="btn">Check Answers</button>
          <div
            id="quizResultStr"
            class="message-box mt-4"
            style="display: none"
          ></div>
        </section>
      </div>

      <footer class="footer-8bit">
        <p>Happy Learning!</p>
        <p class="mt-2">
          <a href="../index.html">Back to Main Menu</a>
        </p>
      </footer>
    </div>

    <script src="../js/main.js" defer></script>
    <script>
      // showMessage is now in js/main.js

      // --- DOM Elements ---
      const str1Input = document.getElementById("str1Input");
      const str2Input = document.getElementById("str2Input");
      const concatButton = document.getElementById("concatButton");
      const strRepeatInput = document.getElementById("strRepeatInput");
      const repeatNumInput = document.getElementById("repeatNumInput");
      const repeatButton = document.getElementById("repeatButton");
      const combineResultDisplay = document.getElementById(
        "combineResultDisplay"
      );
      const combineMessage = document.getElementById("combineMessage");

      const accessStringVis = document.getElementById("accessStringVis");
      const accessIndexInput = document.getElementById("accessIndexInput");
      const accessIndexButton = document.getElementById("accessIndexButton");
      const sliceStartInput = document.getElementById("sliceStartInput");
      const sliceStopInput = document.getElementById("sliceStopInput");
      const sliceStepInput = document.getElementById("sliceStepInput");
      const sliceButton = document.getElementById("sliceButton");
      const accessResultDisplay = document.getElementById(
        "accessResultDisplay"
      );
      const accessStrMessage = document.getElementById("accessStrMessage");
      const accessExampleString = "PixelWorld";

      const methodStrInput = document.getElementById("methodStrInput");
      const methodSelect = document.getElementById("methodSelect");
      const methodArgsContainer = document.getElementById(
        "methodArgsContainer"
      );
      const applyMethodButton = document.getElementById("applyMethodButton");
      const methodResultDisplay = document.getElementById(
        "methodResultDisplay"
      );
      const methodMessage = document.getElementById("methodMessage");

      const checkQuizButtonStr = document.getElementById(
        "checkQuizButtonStr"
      );
      const quizResultStr = document.getElementById("quizResultStr");

      // --- Concatenation & Repetition Logic ---
      concatButton.addEventListener("click", () => {
        const str1 = str1Input.value;
        const str2 = str2Input.value;
        const result = str1 + str2;
        combineResultDisplay.textContent = `"${str1}" + "${str2}" => "${result}"`;
        showMessage(combineMessage, "Concatenation complete.", "success");
      });

      repeatButton.addEventListener("click", () => {
        const str = strRepeatInput.value;
        const numStr = repeatNumInput.value;
        const num = parseInt(numStr, 10);

        if (isNaN(num) || num < 0) {
          showMessage(
            combineMessage,
            "Please enter a non-negative number for repetition.",
            "error"
          );
          combineResultDisplay.textContent =
            '<span class="text-red-500">Error: Invalid number.</span>';
          return;
        }
        const result = str.repeat(num); // Use built-in repeat for simplicity
        combineResultDisplay.textContent = `"${str}" * ${num} => "${result}"`;
        showMessage(combineMessage, "Repetition complete.", "success");
      });

      // --- Indexing & Slicing Logic ---
      function renderStringVisual(container, text) {
        container.innerHTML = "";
        for (let i = 0; i < text.length; i++) {
          const charSpan = document.createElement("span");
          charSpan.className = "string-char";
          charSpan.textContent = text[i];
          charSpan.dataset.index = i;
          container.appendChild(charSpan);
        }
      }

      function clearStringHighlights(container) {
        container.querySelectorAll(".string-char.highlight").forEach((span) => {
          span.classList.remove("highlight");
        });
      }

      accessIndexButton.addEventListener("click", () => {
        clearStringHighlights(accessStringVis);
        const indexStr = accessIndexInput.value;
        if (indexStr === "") {
          showMessage(accessStrMessage, "Please enter an index.", "error");
          accessResultDisplay.textContent =
            '<span class="text-gray-500 italic">Enter index/slice values and click buttons.</span>';
          return;
        }
        const index = parseInt(indexStr, 10);

        try {
          const char = accessExampleString[index];
          if (char === undefined) {
            // Handle out-of-bounds more gracefully than error
            throw new Error("Index out of bounds");
          }
          accessResultDisplay.textContent = `Character at index ${index}: "${char}"`;
          // Highlight the character
          const targetSpan = accessStringVis.querySelector(
            `.string-char[data-index="${
              index < 0 ? accessExampleString.length + index : index
            }"]`
          );
          if (targetSpan) targetSpan.classList.add("highlight");
          showMessage(accessStrMessage, "Character accessed.", "success");
        } catch (e) {
          showMessage(accessStrMessage, "Error: Index out of bounds.", "error");
          accessResultDisplay.textContent =
            '<span class="text-red-500">Error: Index out of bounds.</span>';
        }
      });

      sliceButton.addEventListener("click", () => {
        clearStringHighlights(accessStringVis);
        // Get slice parameters, treating empty as undefined for default behavior
        const start =
          sliceStartInput.value === ""
            ? undefined
            : parseInt(sliceStartInput.value, 10);
        const stop =
          sliceStopInput.value === ""
            ? undefined
            : parseInt(sliceStopInput.value, 10);
        const step =
          sliceStepInput.value === ""
            ? undefined
            : parseInt(sliceStepInput.value, 10);

        // Basic validation for NaN
        if (
          (start !== undefined && isNaN(start)) ||
          (stop !== undefined && isNaN(stop)) ||
          (step !== undefined && isNaN(step))
        ) {
          showMessage(
            accessStrMessage,
            "Invalid number entered for slice parameter.",
            "error"
          );
          accessResultDisplay.textContent =
            '<span class="text-red-500">Error: Invalid slice number.</span>';
          return;
        }
        if (step === 0) {
          showMessage(accessStrMessage, "Slice step cannot be zero.", "error");
          accessResultDisplay.textContent =
            '<span class="text-red-500">Error: Step cannot be zero.</span>';
          return;
        }

        try {
          // Use slice method - handles undefined parameters correctly
          const sliceResult = accessExampleString.slice(start, stop);
          // For step, we need a different approach if step is provided
          let finalResult = sliceResult;
          let indicesToHighlight = [];

          if (step !== undefined) {
            finalResult = "";
            const len = accessExampleString.length;
            const actualStart =
              start === undefined || isNaN(start)
                ? step > 0
                  ? 0
                  : len - 1
                : start < 0
                ? len + start
                : start;
            const actualStop =
              stop === undefined || isNaN(stop)
                ? step > 0
                  ? len
                  : -1
                : stop < 0
                ? len + stop
                : stop;

            if (step > 0) {
              for (let i = actualStart; i < actualStop; i += step) {
                if (i >= 0 && i < len) {
                  finalResult += accessExampleString[i];
                  indicesToHighlight.push(i);
                }
              }
            } else {
              // step < 0
              for (let i = actualStart; i > actualStop; i += step) {
                if (i >= 0 && i < len) {
                  finalResult += accessExampleString[i];
                  indicesToHighlight.push(i);
                }
              }
            }
          } else {
            // Calculate indices for simple slice without step
            const len = accessExampleString.length;
            const actualStart =
              start === undefined || isNaN(start)
                ? 0
                : start < 0
                ? len + start
                : start;
            const actualStop =
              stop === undefined || isNaN(stop)
                ? len
                : stop < 0
                ? len + stop
                : stop;
            for (let i = actualStart; i < actualStop; i++) {
              if (i >= 0 && i < len) {
                indicesToHighlight.push(i);
              }
            }
          }

          accessResultDisplay.textContent = `Slice result: "${finalResult}"`;
          // Highlight characters in the slice
          indicesToHighlight.forEach((idx) => {
            const targetSpan = accessStringVis.querySelector(
              `.string-char[data-index="${idx}"]`
            );
            if (targetSpan) targetSpan.classList.add("highlight");
          });

          showMessage(accessStrMessage, "Slice applied.", "success");
        } catch (e) {
          showMessage(
            accessStrMessage,
            `Error applying slice: ${e.message}`,
            "error"
          );
          accessResultDisplay.textContent = `<span class="text-red-500">Error: ${e.message}</span>`;
        }
      });

      // --- String Methods Logic ---
      function updateMethodArgs() {
        methodArgsContainer.innerHTML = ""; // Clear previous args
        const selectedMethod = methodSelect.value;

        if (selectedMethod === "replace") {
          methodArgsContainer.innerHTML = `
                    <input type="text" id="replaceOld" class="input-field" placeholder="Old Substring">
                    <input type="text" id="replaceNew" class="input-field" placeholder="New Substring">
                `;
        } else if (selectedMethod === "find") {
          methodArgsContainer.innerHTML = `
                    <input type="text" id="findSubstr" class="input-field" placeholder="Substring to Find">
                `;
        } else if (selectedMethod === "split") {
          methodArgsContainer.innerHTML = `
                    <input type="text" id="splitSep" class="input-field" placeholder="Separator (optional)">
                `;
        }
      }

      methodSelect.addEventListener("change", updateMethodArgs);

      applyMethodButton.addEventListener("click", () => {
        const inputStr = methodStrInput.value;
        const method = methodSelect.value;
        let result;
        let resultDisplayStr = "";

        try {
          switch (method) {
            case "len":
              result = inputStr.length;
              resultDisplayStr = `len("${inputStr}") => ${result}`;
              break;
            case "upper":
              result = inputStr.toUpperCase();
              resultDisplayStr = `"${inputStr}".upper() => "${result}"`;
              break;
            case "lower":
              result = inputStr.toLowerCase();
              resultDisplayStr = `"${inputStr}".lower() => "${result}"`;
              break;
            case "strip":
              result = inputStr.strip(); // Use strip() - trim is JS
              resultDisplayStr = `"${inputStr}".strip() => "${result}"`;
              break;
            case "replace":
              const oldSub = document.getElementById("replaceOld").value;
              const newSub = document.getElementById("replaceNew").value;
              result = inputStr.replace(
                new RegExp(oldSub.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"),
                newSub
              ); // Use RegExp for global replace
              resultDisplayStr = `"${inputStr}".replace("${oldSub}", "${newSub}") => "${result}"`;
              break;
            case "find":
              const findSub = document.getElementById("findSubstr").value;
              result = inputStr.indexOf(findSub); // Use indexOf (JS equivalent of find)
              resultDisplayStr = `"${inputStr}".find("${findSub}") => ${result}`;
              break;
            case "split":
              const separator = document.getElementById("splitSep").value;
              // If separator is empty, split by whitespace (default Python behavior simulated)
              // If separator provided, split by it.
              result =
                separator === ""
                  ? inputStr.trim().split(/\s+/)
                  : inputStr.split(separator);
              // Format list output nicely
              const listStr =
                "[" + result.map((item) => `"${item}"`).join(", ") + "]";
              resultDisplayStr = `"${inputStr}".split(${
                separator === "" ? "" : '"' + separator + '"'
              }) => ${listStr}`;
              break;
            default:
              throw new Error("Invalid method selected");
          }
          methodResultDisplay.textContent = resultDisplayStr;
          showMessage(methodMessage, `Method .${method}() applied.`, "success");
        } catch (e) {
          showMessage(methodMessage, `Error: ${e.message}`, "error");
          methodResultDisplay.textContent = `<span class="text-red-500">Error: ${e.message}</span>`;
        }
      });

      // --- Quiz Logic ---
      function checkStringsQuiz() {
        const answers = {
          q1_str: "b", // "+"
          q2_str: "a", // "my_string[0]"
          q3_str: "b", // ".upper() returns a new string with all characters in uppercase"
          q4_str: "b", // "print(f"Name: {name}, Age: {age}")"
        };
        let score = 0;
        let resultsHTML = "<ul>";
        let allAnswered = true;

        for (const q in answers) {
          const selected = document.querySelector(`input[name="${q}"]:checked`);
          if (!selected) {
            allAnswered = false;
            break;
          }
          const isCorrect = selected.value === answers[q];
          if (isCorrect) {
            score++;
            resultsHTML += `<li class="text-green-700">✓ Question ${q.substring(
              1,
              2
            )}: Correct!</li>`;
          } else {
            resultsHTML += `<li class="text-red-700">✗ Question ${q.substring(
              1,
              2
            )}: Incorrect.</li>`;
          }
        }

        if (!allAnswered) {
          quizResultStr.textContent =
            "Please answer all questions before checking.";
          quizResultStr.className = "message-box message-box-error";
          quizResultStr.style.display = "block";
          return;
        }

        resultsHTML += "</ul>";
        resultsHTML =
          `<p class="font-medium mb-2">You scored ${score} out of ${
            Object.keys(answers).length
          }.</p>` + resultsHTML;

        quizResultStr.innerHTML = resultsHTML;
        quizResultStr.className =
          score === Object.keys(answers).length
            ? "message-box message-box-success"
            : "message-box message-box-error";
        quizResultStr.style.display = "block";
      }

      // --- Event Listeners ---
      checkQuizButtonStr.addEventListener("click", checkStringsQuiz);

      // --- Initial Setup ---
      renderStringVisual(accessStringVis, accessExampleString);
      updateMethodArgs(); // Set initial argument fields for default method
    </script>
  </body>
</html>
