<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2D Lists (Lists of Lists) - Python Guide</title>
    <!-- <script src="https://cdn.tailwindcss.com"></script> -->
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/shared-styles.css">
  </head>
  <body class="min-h-screen">
    <div class="console-screen-border">
      <header class="text-center mb-12 md:mb-16">
        <h1 class="pixel-header">
          Interactive Python Guide
        </h1>
        <p class="pixel-subheader mt-4">
          Retro Journey into Code!
        </p>
      </header>

      <main class="mx-auto">
        <h1 class="page-title-8bit">
          2D Lists (Lists of Lists / Matrices)
        </h1>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            1. What is a 2D List?
          </h2>
          <div class="sub-interactive-box">
            <p>
              A 2D list, often referred to as a list of lists or sometimes a matrix (especially in mathematical contexts), is a versatile data structure in Python. It's essentially a list where each element is itself another list. This structure is exceptionally useful for representing data that has a grid-like or tabular format, such as:
            </p>
            <ul>
              <li>Game boards (e.g., chess, tic-tac-toe, mazes)</li>
              <li>Tables of data (like a spreadsheet)</li>
              <li>Matrices in mathematics for various calculations</li>
              <li>Pixel data for images</li>
            </ul>
            <p>Think of a 2D list like a spreadsheet or a grid of cells. Just as a spreadsheet has rows and columns, a 2D list has rows (the outer lists) and columns (the elements within each inner list). This structure allows us to organize data in a way that's easy to navigate and manipulate.</p>
            <p>Here's a simple way to visualize and create a 2D list:</p>
            <pre><code class="code-block-8bit python"># A 3x4 grid (3 rows, 4 columns)
grid = [
  [1, 2, 3, 4],    # Row 0
  [5, 6, 7, 8],    # Row 1
  [9, 10, 11, 12]  # Row 2
]

# Each inner list is a row.
# The elements of the inner lists are the columns.

print("Grid:")
for row in grid:
    print(row)

# Output:
# Grid:
# [1, 2, 3, 4]
# [5, 6, 7, 8]
# [9, 10, 11, 12]</code></pre>
            <p>In this example, <code>grid</code> is a list containing three other lists. <code>grid[0]</code> is the list <code>[1, 2, 3, 4]</code>, which represents the first row. It's like having a spreadsheet where each row is a separate list, and each cell in that row is an element of that list.</p>
          </div>
        </section>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            2. Creating 2D Lists
          </h2>
          <div class="sub-interactive-box">
            <p>There are several ways to create 2D lists in Python, each with its own use case:</p>
            <h3 class="section-subtitle-8bit smaller-subtitle">a) Direct Initialization:</h3>
            <p>As shown above, you can directly define the list of lists. This is like manually filling out a spreadsheet - you know exactly what goes in each cell.</p>
            <pre><code class="code-block-8bit python">tic_tac_toe_board = [
    ['X', 'O', 'X'],
    ['O', 'X', ' '],
    ['O', ' ', 'O']
]</code></pre>
            
            <h3 class="section-subtitle-8bit smaller-subtitle">b) Using Nested Loops:</h3>
            <p>You can create a 2D list dynamically, for example, to initialize a grid with default values. This is like having a spreadsheet template where you want to start with the same value in every cell.</p>
            <pre><code class="code-block-8bit python">rows = 3
cols = 3
empty_grid = []
for r in range(rows):
    new_row = []
    for c in range(ncols):
        new_row.append(0) # Initialize with 0
    empty_grid.append(new_row)

# empty_grid will be: [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
print(empty_grid)</code></pre>

            <h3 class="section-subtitle-8bit smaller-subtitle">c) Using List Comprehension (More Pythonic):</h3>
            <p>List comprehensions provide a concise way to create lists. A nested list comprehension can create a 2D list efficiently. Think of this as a more elegant way to create your spreadsheet - it's like having a formula that automatically fills in all the cells.</p>
            <pre><code class="code-block-8bit python">rows = 2
cols = 4
comprehension_grid = [[None for _ in range(cols)] for _ in range(rows)]
# comprehension_grid will be: [[None, None, None, None], [None, None, None, None]]
print(comprehension_grid)</code></pre>
            <div class="message-box-8bit info">
                <strong>Watch Out for Shallow Copies!</strong> When creating lists of lists, especially by repeating a row (e.g., <code>row = [0]*cols; grid = [row]*rows</code>), be careful. This creates multiple references to the <em>same</em> inner list object. It's like having multiple windows open to the same spreadsheet - changes in one window affect all of them. Using loops or list comprehensions as shown above avoids this issue by creating distinct inner list objects for each row, like having separate spreadsheets for each row.
            </div>
          </div>
        </section>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            3. Accessing Elements in a 2D List
          </h2>
          <div class="sub-interactive-box">
            <p>
              To access a specific element in a 2D list, you use two indices: the first index for the row and the second index for the column. Remember that Python uses zero-based indexing, so the first row is at index 0, and the first column is at index 0. It's like using coordinates on a map - you need both the row number and column number to find a specific location.
            </p>
            <p>
              The syntax is: <code>list_name[row_index][column_index]</code>
            </p>
            <pre><code class="code-block-8bit python">game_map = [
  ['Grass', 'Water', 'Water'],  # Row 0
  ['Grass', 'Grass', 'Bridge'], # Row 1
  ['Road',  'Road',  'Grass']   # Row 2
]

# Access the element at Row 0, Column 1 (should be 'Water')
element_0_1 = game_map[0][1]
print(f"Element at [0][1]: {element_0_1}")  # Output: Water

# Access the element at Row 1, Column 2 (should be 'Bridge')
element_1_2 = game_map[1][2]
print(f"Element at [1][2]: {element_1_2}")  # Output: Bridge

# Access an entire row (Row 2)
third_row_data = game_map[2]
print(f"Row 2 data: {third_row_data}")  # Output: ['Road', 'Road', 'Grass']

# Modify an element
print(f"Original element at [0][0]: {game_map[0][0]}")
game_map[0][0] = 'Forest'
print(f"Modified element at [0][0]: {game_map[0][0]}") # Output: Forest</code></pre>
            <div class="message-box-8bit warning">
              <strong>IndexError Alert:</strong> Be careful! Accessing an index that is outside the valid range for rows or columns (e.g., <code>game_map[3]</code> or <code>game_map[0][5]</code> in the example above) will result in an <code>IndexError</code>. This is like trying to find a location on a map that doesn't exist - you'll get lost!
            </div>
          </div>
        </section>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            Interactive: Explore a Grid
          </h2>
          <div class="sub-interactive-box">
            <p>
              Enter a row and column index below to see the corresponding element highlighted in the example 3x4 grid. Valid row indices are 0-2, and valid column indices are 0-3.
            </p>
            <div class="controls-grid grid-2col-responsive">
              <div>
                <label for="rowIndexInput">Row Index (0-2):</label>
                <input
                  type="number"
                  id="rowIndexInput"
                  class="input-field-8bit"
                  placeholder="e.g., 1"
                  min="0"
                  max="2"
                />
              </div>
              <div>
                <label for="colIndexInput">Column Index (0-3):</label>
                <input
                  type="number"
                  id="colIndexInput"
                  class="input-field-8bit"
                  placeholder="e.g., 2"
                  min="0"
                  max="3"
                />
              </div>
            </div>
            <div class="controls-flex mt-2">
                <button id="accessElementButton" class="button-8bit">Show Element</button>
                <button id="accessClearButton" class="button-8bit">Clear</button>
            </div>
   
            <div class="grid-cols-2-responsive mt-4">
              <div>
                <h3 class="section-subtitle-8bit smaller-subtitle">Example Grid (3x4):</h3>
                <div id="gridVisualizerContainer">
                    <table id="gridVisualizerTable" class="grid-table-8bit"></table>
                </div>
              </div>
              <div>
                <h3 class="section-subtitle-8bit smaller-subtitle">Selected Element:</h3>
                <div id="accessResultDisplay" class="output-display-8bit min-h-[40px]">
                  <p><em>Enter indices and click 'Show Element'.</em></p>
                </div>
              </div>
            </div>
            <div id="accessMessage" class="message-box-8bit mt-2" style="display: none;"></div>
          </div>
        </section>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            4. Iterating Through 2D Lists
          </h2>
          <div class="sub-interactive-box">
            <p>
              To process every element in a 2D list, nested loops are commonly used. The outer loop iterates through the rows (which are lists themselves), and the inner loop iterates through the elements (columns) within the current row. Think of this as systematically scanning through a spreadsheet, row by row, and within each row, cell by cell.
            </p>
            <h3 class="section-subtitle-8bit smaller-subtitle">a) Using Nested <code>for</code> Loops with Indices:</h3>
            <pre><code class="code-block-8bit python">data_table = [
  ['Name', 'Score', 'Level'],
  ['PlayerA', 1500, 12],
  ['PlayerB', 2200, 18],
  ['PlayerC', 950, 7]
]

print("Iterating by index:")
# Outer loop iterates through row indices
for r_idx in range(len(data_table)):
  # Inner loop iterates through column indices for the current row
  for c_idx in range(len(data_table[r_idx])):
    element = data_table[r_idx][c_idx]
    print(f"  Element at [{r_idx}][{c_idx}]: {element}")</code></pre>
            <h3 class="section-subtitle-8bit smaller-subtitle">b) Iterating Directly Through Rows and Elements (More Pythonic):</h3>
            <pre><code class="code-block-8bit python">data_table = [
  ['Name', 'Score', 'Level'],
  ['PlayerA', 1500, 12],
  ['PlayerB', 2200, 18],
  ['PlayerC', 950, 7]
]

print("\nIterating directly through elements:")
# Outer loop gets each inner list (row)
for row_list in data_table:
  # Inner loop gets each element in the current row_list
  for item in row_list:
    print(f"  Processing item: {item}")
  print("--- Next Row ---") # Separator for clarity
</code></pre>
            <h3 class="section-subtitle-8bit smaller-subtitle">c) Using <code>enumerate</code> for Index and Value:</h3>
            <p>If you need both the index and the value during iteration:</p>
            <pre><code class="code-block-8bit python">pixel_map = [[(255,0,0), (0,255,0)], [(0,0,255), (255,255,0)]] # (R,G,B) tuples

print("\nIterating with enumerate:")
for r_idx, row_list in enumerate(pixel_map):
    for c_idx, pixel_color in enumerate(row_list):
        print(f"  Pixel at Row {r_idx}, Col {c_idx} is {pixel_color}")</code></pre>
          </div>
        </section>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            5. Common Operations with 2D Lists
          </h2>
          <div class="sub-interactive-box">
            <h3 class="section-subtitle-8bit smaller-subtitle">a) Getting Dimensions (Number of Rows and Columns):</h3>
            <p>Just as you might want to know the size of a spreadsheet (how many rows and columns it has), you can get the dimensions of a 2D list. This is useful for bounds checking and understanding the structure of your data.</p>
            <pre><code class="code-block-8bit python">my_grid = [[1,2,3], [4,5,6], [7,8,9], [10,11,12]]
num_rows = len(my_grid)
# For a non-empty grid where all rows have the same length:
num_cols = len(my_grid[0]) if num_rows > 0 else 0

print(f"Number of rows: {num_rows}")    # Output: 4
print(f"Number of columns: {num_cols}") # Output: 3 (assuming all rows same length)

# What if rows have different lengths (jagged array)?
jagged_grid = [[1,2], [3,4,5], [6]]
print(f"Length of first row: {len(jagged_grid[0])}") # 2
print(f"Length of second row: {len(jagged_grid[1])}") # 3</code></pre>
            <h3 class="section-subtitle-8bit smaller-subtitle">b) Summing All Elements (if numerical):</h3>
            <p>When working with numerical data in a 2D list, you might want to calculate the sum of all elements. This is like using a spreadsheet's SUM function to add up all the values in a range of cells.</p>
            <pre><code class="code-block-8bit python">scores = [[10, 15], [20, 25], [5, 30]]
total_sum = 0
for row in scores:
    for score_value in row:
        total_sum += score_value
print(f"Total sum of all scores: {total_sum}") # Output: 105</code></pre>
            <h3 class="section-subtitle-8bit smaller-subtitle">c) Finding an Element:</h3>
            <p>Searching for a specific element in a 2D list is like looking for a particular item in a spreadsheet. You need to check each cell until you find what you're looking for, or determine that it's not there.</p>
            <pre><code class="code-block-8bit python">treasure_map = [
    ['Sand', 'Palm Tree', 'Rock'],
    ['Water', 'X marks the spot', 'Sand'],
    ['Rock', 'Sand', 'Cave']
]

def find_item_location(grid, item_to_find):
    for r_idx, row in enumerate(grid):
        for c_idx, current_item in enumerate(row):
            if current_item == item_to_find:
                return (r_idx, c_idx) # Return (row, col) tuple
    return None # Item not found

treasure_location = find_item_location(treasure_map, 'X marks the spot')
if treasure_location:
    print(f"Treasure found at row {treasure_location[0]}, col {treasure_location[1]}")
    # Output: Treasure found at row 1, col 1
else:
    print("Treasure not found!")</code></pre>
          </div>
        </section>

      </main>

      <footer class="footer-8bit text-center py-6">
        <p class="text-md md:text-lg">Happy Coding, Player 1!</p>
        <p class="mt-3 md:mt-4">
          <a
            href="../index.html"
            class="link-8bit"
            >Back to Main Menu</a>
          >
        </p>
      </footer>
    </div> <!-- End of console-screen-border -->

    <script>
      const exampleGridData = [
        [10, 20, 30, 40],
        [50, 60, 70, 80],
        [90, 100, 110, 120]
      ];

      const gridTable = document.getElementById('gridVisualizerTable');
      const rowIndexInput = document.getElementById('rowIndexInput');
      const colIndexInput = document.getElementById('colIndexInput');
      const accessElementButton = document.getElementById('accessElementButton');
      const accessResultDisplay = document.getElementById('accessResultDisplay');
      const accessMessage = document.getElementById('accessMessage');
      const accessClearButton = document.getElementById('accessClearButton');
      
      let highlightedCell = null;

      function renderGrid() {
        gridTable.innerHTML = ''; // Clear previous grid
        const headerRow = gridTable.insertRow();
        const th = document.createElement('th'); // Empty top-left corner
        headerRow.appendChild(th);
        for (let j = 0; j < exampleGridData[0].length; j++) {
            const thCol = document.createElement('th');
            thCol.textContent = `Col ${j}`;
            headerRow.appendChild(thCol);
        }
        exampleGridData.forEach((rowData, r) => {
          const tr = gridTable.insertRow();
          const thRow = document.createElement('th');
          thRow.textContent = `Row ${r}`;
          tr.appendChild(thRow);
          rowData.forEach((cellData, c) => {
            const td = tr.insertCell();
            td.textContent = cellData;
            td.id = `cell-${r}-${c}`;
          });
        });
      }

      function clearHighlight() {
        if (highlightedCell) {
          highlightedCell.classList.remove('highlight-8bit');
          highlightedCell = null;
        }
      }

      function showAccessMessage(message, type = 'info') {
        accessMessage.textContent = message;
        accessMessage.className = 'message-box-8bit mt-2'; // Reset base classes
        if (type === 'error') {
          accessMessage.classList.add('error');
        } else if (type === 'success') {
          accessMessage.classList.add('success');
        } else {
           accessMessage.classList.add('info'); // Default to info
        }
        accessMessage.style.display = 'block';
      }

      function hideAccessMessage() {
          accessMessage.style.display = 'none';
      }

      accessElementButton.addEventListener('click', () => {
        clearHighlight();
        hideAccessMessage();
        accessResultDisplay.innerHTML = '<p><em>Processing...</em></p>';
        const row = parseInt(rowIndexInput.value);
        const col = parseInt(colIndexInput.value);

        if (isNaN(row) || isNaN(col)) {
          accessResultDisplay.innerHTML = '<p>Invalid input. Please enter numbers for row and column.</p>';
          showAccessMessage('Row and Column must be numbers!', 'error');
          return;
        }

        if (row >= 0 && row < exampleGridData.length && col >= 0 && col < exampleGridData[0].length) {
          const selectedValue = exampleGridData[row][col];
          accessResultDisplay.innerHTML = `<p>Value at [${row}][${col}]: <strong>${selectedValue}</strong></p>`;
          const cellId = `cell-${row}-${col}`;
          highlightedCell = document.getElementById(cellId);
          if (highlightedCell) {
            highlightedCell.classList.add('highlight-8bit');
          }
          showAccessMessage(`Element [${row}][${col}] = ${selectedValue} highlighted!`, 'success');
        } else {
          accessResultDisplay.innerHTML = '<p>Index out of bounds for the example grid.</p>';
          showAccessMessage('Indices are out of bounds! Valid Rows: 0-2, Valid Cols: 0-3.', 'error');
        }
      });

      accessClearButton.addEventListener('click', () => {
          clearHighlight();
          hideAccessMessage();
          rowIndexInput.value = '';
          colIndexInput.value = '';
          accessResultDisplay.innerHTML = '<p><em>Enter indices and click \'Show Element\'.</em></p>';
      });

      // Initial render of the grid
      renderGrid();
      accessClearButton.click(); // To set initial placeholder message in result display
    </script>
  </body>
</html>
