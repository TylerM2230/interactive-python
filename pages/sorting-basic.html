<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Basic Sorting - Python Guide</title>
    <!-- <script src="https://cdn.tailwindcss.com"></script> -->
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/shared-styles.css">
    <style>
      /* Styles for sort visualization - preserved as they use theme colors */
      .sort-container {
        display: flex;
        align-items: flex-end; /* Align bars at the bottom */
        justify-content: center;
        min-height: 150px;
        padding: 10px;
        background-color: #503020; /* Deep Bark */
        border: 3px solid #706050; /* Lighter Bark/Moss */
        border-top-color: #302010;
        border-left-color: #302010;
        border-radius: 6px;
        margin-bottom: 10px;
      }
      .sort-bar {
        background-color: #f0c060; /* Sunlight Gold */
        border: 1px solid #a07030; /* Darker Brownish Gold */
        margin: 0 2px;
        width: 20px; /* Adjust as needed */
        transition: height 0.3s ease, background-color 0.3s ease;
      }
      .sort-bar.comparing {
        background-color: #80b0d0; /* Sky Blue */
      }
      .sort-bar.swapping {
        background-color: #40a090; /* Mystic Teal */
      }
      .sort-bar.sorted {
        background-color: #60c0b0; /* Lighter Mystic Teal for sorted elements */
      }
       .sort-bar.minimum { /* For Selection Sort visualization */
        background-color: #f8e8c0; /* Pale Gold for current minimum */
      }
    </style>
  </head>
  <body class="min-h-screen">
    <div class="console-screen-border">
      <header class="text-center mb-12 md:mb-16">
        <h1 class="pixel-header">
          Interactive Python Guide
        </h1>
        <p class="pixel-subheader mt-4">
          Retro Journey into Code!
        </p>
      </header>

      <main class="mx-auto">
        <h1 class="page-title-8bit">
          Basic Sorting Algorithms
        </h1>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            1. What is Sorting?
          </h2>
          <div class="sub-interactive-box">
            <p>
              Sorting is the process of arranging items in a collection (like a list or array) into a specific order, which can be numerical (ascending or descending) or lexicographical (alphabetical). It's a fundamental and frequently performed operation in computer science. Think of it like organizing a deck of cards - you can arrange them by suit, by number, or any other rule, but the goal is to have a specific, predictable order.
            </p>
            <p>Why is sorting important?</p>
            <ul>
              <li><strong>Efficient Searching:</strong> Searching for an item in a sorted collection is significantly faster (e.g., using binary search, which requires sorted data). Like having a phone book - it's much easier to find a number when the names are in alphabetical order.</li>
              <li><strong>Data Presentation:</strong> Sorted data is often easier for humans to read, understand, and analyze. Like having your music playlist sorted by artist - it's much easier to find your favorite songs.</li>
              <li><strong>Algorithmic Prerequisite:</strong> Many algorithms require their input data to be sorted to function correctly or efficiently. Like having to arrange puzzle pieces by color before you can start solving the puzzle.</li>
              <li><strong>Database Operations:</strong> Databases extensively use sorting for indexing and query optimization. Like having a library's card catalog system - it helps you find books quickly because they're organized in a specific way.</li>
            </ul>
          </div>
        </section>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            2. Bubble Sort
          </h2>
          <div class="sub-interactive-box">
            <p>
              Bubble Sort is a simple comparison-based sorting algorithm. It repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. The largest (or smallest, depending on sort order) elements "bubble" to their correct position at the end of the list with each pass. Think of it like bubbles rising in a glass of soda - larger bubbles naturally rise to the top, just as larger numbers "bubble up" to their correct positions in the list.
            </p>
            <p><strong>How it works:</strong></p>
            <ol>
              <li>Iterate through the list from the first element to the second-to-last. Like checking each pair of students in a line to see if they're in the right order by height.</li>
              <li>In each iteration, compare the current element with the next element. Like looking at two students standing next to each other.</li>
              <li>If the current element is greater than the next element (for ascending order), swap them. Like having the taller student step back to let the shorter student move forward.</li>
              <li>After the first full pass, the largest element will have "bubbled up" to the last position. Like the tallest student ending up at the end of the line after one round of comparisons.</li>
              <li>Repeat the passes, reducing the range of comparison by one element each time (since the last elements are already in place), until a full pass completes with no swaps. Like continuing to organize the remaining students, but each time you can ignore one more student at the end of the line because they're already in the right place.</li>
            </ol>
            <p>
              Bubble Sort is easy to understand and implement but is generally inefficient for large lists, with an average and worst-case time complexity of O(n²).
            </p>

            <h3 class="section-subtitle-8bit smaller-subtitle">Visualize Bubble Sort:</h3>
            <div class="controls-flex">
              <button id="runBubbleSortButton" class="button-8bit">Run Bubble Sort</button>
              <button id="resetBubbleSortButton" class="button-8bit">Reset</button>
              <label for="bubbleSpeedRange">Speed:</label>
              <input type="range" id="bubbleSpeedRange" min="50" max="1000" value="300" step="50" class="input-field-8bit range-slider"/>
            </div>
            <div id="bubbleSortContainer" class="sort-container"></div>
            <h4 class="section-subtitle-8bit smaller-subtitle">Log:</h4>
            <div id="bubbleSortLog" class="output-display-8bit min-h-[100px]">
              <p><em>Click 'Run Bubble Sort' to start. Initial array: [64, 34, 25, 12, 22, 11, 90, 50, 77, 8]</em></p>
            </div>
            <div id="bubbleSortMessage" class="message-box-8bit" style="display: none;"></div>
          </div>
        </section>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            3. Selection Sort
          </h2>
          <div class="sub-interactive-box">
            <p>
              Selection Sort is another simple, in-place comparison sorting algorithm. It divides the input list into two parts: a sorted sublist (initially empty) which is built up from left to right at the front of the list, and an unsorted sublist which makes up the rest of the list. The algorithm proceeds by finding the smallest (or largest, depending on sort order) element in the unsorted sublist, swapping it with the leftmost unsorted element, and moving the sublist boundaries one element to the right. Think of it like organizing a hand of cards - you look through your cards to find the lowest one, put it at the start, then look through the remaining cards to find the next lowest, and so on.
            </p>
            <p><strong>How it works:</strong></p>
            <ol>
              <li>Iterate from the first element to the second-to-last element of the list (this loop variable, say `i`, marks the end of the sorted part). Like having a line of students where the first few are already arranged by height.</li>
              <li>In each iteration, assume the element at the current position `i` is the minimum (or maximum). Like temporarily marking a student as the shortest in the unsorted part of the line.</li>
              <li>Iterate through the remaining unsorted part of the list (from `i+1` to the end) to find the actual minimum (or maximum) element. Like looking through the rest of the unsorted students to find the shortest one.</li>
              <li>If a smaller (or larger) element is found, update the record of the minimum (or maximum) element's index. Like finding an even shorter student and updating your mental note of who's the shortest.</li>
              <li>After scanning the entire unsorted part, if the minimum (or maximum) element found is not at position `i`, swap it with the element at position `i`. Like having the shortest student from the unsorted part swap places with the student at the end of the sorted part.</li>
              <li>Repeat until the list is sorted. Like continuing this process until all students are arranged by height.</li>
            </ol>
            <p>
              Selection Sort also has a time complexity of O(n²) in all cases (worst, average, and best). While its time complexity is similar to Bubble Sort, it generally performs fewer swaps.
            </p>

            <h3 class="section-subtitle-8bit smaller-subtitle">Visualize Selection Sort:</h3>
            <div class="controls-flex">
              <button id="runSelectionSortButton" class="button-8bit">Run Selection Sort</button>
              <button id="resetSelectionSortButton" class="button-8bit">Reset</button>
              <label for="selectionSpeedRange">Speed:</label>
              <input type="range" id="selectionSpeedRange" min="50" max="1000" value="400" step="50" class="input-field-8bit range-slider"/>
            </div>
            <div id="selectionSortContainer" class="sort-container"></div>
            <h4 class="section-subtitle-8bit smaller-subtitle">Log:</h4>
            <div id="selectionSortLog" class="output-display-8bit min-h-[100px]">
               <p><em>Click 'Run Selection Sort' to start. Initial array: [64, 34, 25, 12, 22, 11, 90, 50, 77, 8]</em></p>
            </div>
            <div id="selectionSortMessage" class="message-box-8bit" style="display: none;"></div>
          </div>
        </section>
        
        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">Code Examples</h2>
          <div class="sub-interactive-box">
            <p>Python implementations of Bubble Sort and Selection Sort:</p>
            <h3 class="section-subtitle-8bit smaller-subtitle">Bubble Sort:</h3>
            <pre><code class="code-block-8bit python">def bubble_sort(arr):
    n = len(arr)
    # Traverse through all array elements
    for i in range(n):
        swapped = False
        # Last i elements are already in place
        for j in range(0, n - i - 1):
            # Traverse the array from 0 to n-i-1
            # Swap if the element found is greater
            # than the next element
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        
        # If no two elements were swapped by inner loop, then break
        if not swapped:
            break
    return arr

# Example usage:
my_array = [64, 34, 25, 12, 22, 11, 90]
print(f"Original array: {my_array}")
bubble_sort(my_array)
print(f"Sorted array (Bubble Sort): {my_array}")</code></pre>
            <h3 class="section-subtitle-8bit smaller-subtitle">Selection Sort:</h3>
            <pre><code class="code-block-8bit python">def selection_sort(arr):
    n = len(arr)
    # Traverse through all array elements
    for i in range(n):
        # Find the minimum element in remaining unsorted array
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
                
        # Swap the found minimum element with the first element
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

# Example usage:
another_array = [64, 25, 12, 22, 11, 50, 90]
print(f"Original array: {another_array}")
selection_sort(another_array)
print(f"Sorted array (Selection Sort): {another_array}")</code></pre>
          </div>
        </section>
      </main>

      <footer class="footer-8bit text-center py-6">
        <p class="text-md md:text-lg">Happy Coding, Player 1!</p>
        <p class="mt-3 md:mt-4">
          <a
            href="../index.html" 
            class="link-8bit" 
            >Back to Main Menu</a 
          >
        </p>
      </footer>
    </div> <!-- End of console-screen-border -->

    <script>
        const initialArrayDefault = [64, 34, 25, 12, 22, 11, 90, 50, 77, 8];
        let currentBubbleArray = [...initialArrayDefault];
        let currentSelectionArray = [...initialArrayDefault];

        let bubbleSortSpeed = 300;
        let selectionSortSpeed = 400;
        let bubbleAnimationTimeout = null;
        let selectionAnimationTimeout = null;

        const bubbleSpeedRange = document.getElementById('bubbleSpeedRange');
        const selectionSpeedRange = document.getElementById('selectionSpeedRange');

        bubbleSpeedRange.addEventListener('input', (e) => bubbleSortSpeed = parseInt(e.target.value));
        selectionSpeedRange.addEventListener('input', (e) => selectionSortSpeed = parseInt(e.target.value));

        function createBars(containerId, arr, specificMaxValue = null) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';
            const maxValue = specificMaxValue || Math.max(...arr, 10); // Ensure a minimum height
            arr.forEach(value => {
                const bar = document.createElement('div');
                bar.classList.add('sort-bar');
                const percentageHeight = maxValue === 0 ? 0 : (value / maxValue) * 100;
                bar.style.height = `${Math.max(percentageHeight, 5)}%`; // Ensure a minimum visible height
                bar.dataset.value = value;
                container.appendChild(bar);
            });
        }
        
        function updateBarClasses(bars, index, action) { // action: 'comparing', 'swapping', 'sorted', 'minimum', 'clear'
            if (!bars || !bars[index]) return;
            bars[index].classList.remove('comparing', 'swapping', 'sorted', 'minimum');
            if (action !== 'clear') {
                bars[index].classList.add(action);
            }
        }
        
        function logToSort(logId, message) {
            const logArea = document.getElementById(logId);
            if (!logArea) return;
            const p = document.createElement('p');
            p.innerHTML = message; // Allow simple HTML for emphasis if needed
            logArea.appendChild(p);
            logArea.scrollTop = logArea.scrollHeight;
        }

        function showSortMessage(messageId, text, type = 'info') {
            const messageBox = document.getElementById(messageId);
            if (!messageBox) return;
            messageBox.textContent = text;
            messageBox.className = 'message-box-8bit'; // Reset classes
            if (type === 'success') messageBox.classList.add('success');
            else if (type === 'error') messageBox.classList.add('error');
            messageBox.style.display = 'block';
        }

        function hideSortMessage(messageId) {
            const messageBox = document.getElementById(messageId);
            if (messageBox) messageBox.style.display = 'none';
        }

        // --- Bubble Sort ---
        const runBubbleSortButton = document.getElementById('runBubbleSortButton');
        const resetBubbleSortButton = document.getElementById('resetBubbleSortButton');
        const bubbleSortContainer = document.getElementById('bubbleSortContainer');
        const bubbleSortLog = document.getElementById('bubbleSortLog');

        async function bubbleSortVisualize() {
            if (bubbleAnimationTimeout) clearTimeout(bubbleAnimationTimeout);
            runBubbleSortButton.disabled = true;
            resetBubbleSortButton.disabled = true;
            hideSortMessage('bubbleSortMessage');
            bubbleSortLog.innerHTML = '<p><em>Starting Bubble Sort...</em></p>';
            let arr = [...currentBubbleArray];
            const n = arr.length;
            const bars = bubbleSortContainer.childNodes;

            logToSort('bubbleSortLog', `Initial array: [${arr.join(', ')}]`);

            for (let i = 0; i < n - 1; i++) {
                let swapped = false;
                logToSort('bubbleSortLog', `<strong>Pass ${i + 1}:</strong>`);
                for (let j = 0; j < n - i - 1; j++) {
                    updateBarClasses(bars, j, 'comparing');
                    updateBarClasses(bars, j + 1, 'comparing');
                    await new Promise(resolve => bubbleAnimationTimeout = setTimeout(resolve, bubbleSortSpeed));

                    logToSort('bubbleSortLog', `Comparing ${arr[j]} and ${arr[j+1]}`);
                    if (arr[j] > arr[j + 1]) {
                        logToSort('bubbleSortLog', `Swapping ${arr[j]} and ${arr[j+1]}`);
                        updateBarClasses(bars, j, 'swapping');
                        updateBarClasses(bars, j + 1, 'swapping');
                        await new Promise(resolve => bubbleAnimationTimeout = setTimeout(resolve, bubbleSortSpeed));
                        
                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                        swapped = true;
                        createBars('bubbleSortContainer', arr, Math.max(...initialArrayDefault, 10)); // Redraw with new heights
                        updateBarClasses(bubbleSortContainer.childNodes, j, 'swapping'); // Reapply class after redraw
                        updateBarClasses(bubbleSortContainer.childNodes, j + 1, 'swapping');
                        await new Promise(resolve => bubbleAnimationTimeout = setTimeout(resolve, bubbleSortSpeed));
                    }
                    updateBarClasses(bars, j, 'clear');
                    updateBarClasses(bars, j + 1, 'clear');
                     // Mark the already sorted part (at the end of the array after pass i)
                    if (bars[n - 1 - i]) updateBarClasses(bars, n - 1 - i, 'sorted');
                }
                if (bars[n - 1 - i]) updateBarClasses(bars, n - 1 - i, 'sorted'); // Mark as sorted
                if (!swapped) {
                    logToSort('bubbleSortLog', 'No swaps in this pass. Array is sorted.');
                    break;
                }
            }
            // Mark all bars as sorted at the end
            for(let k=0; k < n; k++) updateBarClasses(bars, k, 'sorted');
            logToSort('bubbleSortLog', `Bubble Sort Complete. Sorted array: [${arr.join(', ')}]`);
            showSortMessage('bubbleSortMessage', 'Bubble Sort Complete!', 'success');
            runBubbleSortButton.disabled = false;
            resetBubbleSortButton.disabled = false;
            currentBubbleArray = arr; // Persist sorted array for next potential reset
        }

        function resetBubbleSort() {
            if (bubbleAnimationTimeout) clearTimeout(bubbleAnimationTimeout);
            currentBubbleArray = [...initialArrayDefault];
            createBars('bubbleSortContainer', currentBubbleArray, Math.max(...initialArrayDefault, 10));
            bubbleSortLog.innerHTML = `<p><em>Bubble sort reset. Initial array: [${currentBubbleArray.join(', ')}]</em></p>`;
            hideSortMessage('bubbleSortMessage');
            runBubbleSortButton.disabled = false;
            resetBubbleSortButton.disabled = false;
        }

        runBubbleSortButton.addEventListener('click', bubbleSortVisualize);
        resetBubbleSortButton.addEventListener('click', resetBubbleSort);
        

        // --- Selection Sort ---
        const runSelectionSortButton = document.getElementById('runSelectionSortButton');
        const resetSelectionSortButton = document.getElementById('resetSelectionSortButton');
        const selectionSortContainer = document.getElementById('selectionSortContainer');
        const selectionSortLog = document.getElementById('selectionSortLog');

        async function selectionSortVisualize() {
            if (selectionAnimationTimeout) clearTimeout(selectionAnimationTimeout);
            runSelectionSortButton.disabled = true;
            resetSelectionSortButton.disabled = true;
            hideSortMessage('selectionSortMessage');
            selectionSortLog.innerHTML = '<p><em>Starting Selection Sort...</em></p>';
            let arr = [...currentSelectionArray];
            const n = arr.length;
            const bars = selectionSortContainer.childNodes;
            const maxVal = Math.max(...initialArrayDefault, 10);

            logToSort('selectionSortLog', `Initial array: [${arr.join(', ')}]`);

            for (let i = 0; i < n - 1; i++) {
                let min_idx = i;
                updateBarClasses(bars, i, 'minimum'); // Current assumed minimum
                logToSort('selectionSortLog', `<strong>Pass ${i + 1}:</strong> Finding minimum for position ${i} (current value ${arr[i]})`);
                await new Promise(resolve => selectionAnimationTimeout = setTimeout(resolve, selectionSortSpeed));

                for (let j = i + 1; j < n; j++) {
                    updateBarClasses(bars, j, 'comparing');
                    logToSort('selectionSortLog', `Comparing ${arr[min_idx]} (current min) with ${arr[j]}`);
                    await new Promise(resolve => selectionAnimationTimeout = setTimeout(resolve, selectionSortSpeed));
                    if (arr[j] < arr[min_idx]) {
                        logToSort('selectionSortLog', `${arr[j]} < ${arr[min_idx]}. New minimum found: ${arr[j]}`);
                        if(min_idx !== i) updateBarClasses(bars, min_idx, 'clear'); // Clear previous minimum if it wasn't the start of pass
                        min_idx = j;
                        updateBarClasses(bars, min_idx, 'minimum'); // Highlight new minimum
                        await new Promise(resolve => selectionAnimationTimeout = setTimeout(resolve, selectionSortSpeed));
                    }
                    if (j !== min_idx) updateBarClasses(bars, j, 'clear'); // Clear non-minimum comparison
                }

                if (min_idx !== i) {
                    logToSort('selectionSortLog', `Swapping ${arr[i]} with ${arr[min_idx]} (minimum for this pass)`);
                    updateBarClasses(bars, i, 'swapping');
                    updateBarClasses(bars, min_idx, 'swapping'); // min_idx is already 'minimum', add 'swapping'
                    await new Promise(resolve => selectionAnimationTimeout = setTimeout(resolve, selectionSortSpeed));
                    
                    [arr[i], arr[min_idx]] = [arr[min_idx], arr[i]];
                    createBars('selectionSortContainer', arr, maxVal); // Redraw
                    updateBarClasses(selectionSortContainer.childNodes, i, 'sorted'); // New item is sorted
                    if (min_idx > i) updateBarClasses(selectionSortContainer.childNodes, min_idx, 'clear'); // Clear the original spot of min_idx if it moved
                } else {
                     logToSort('selectionSortLog', `${arr[i]} is already in correct position for this pass.`);
                }
                updateBarClasses(bars, i, 'sorted'); // Mark as sorted
                 // Clear any lingering minimum highlights from previous inner loop iterations
                for(let k = i + 1; k < n; k++) updateBarClasses(bars, k, 'clear');
            }
            if (bars[n-1]) updateBarClasses(bars, n - 1, 'sorted'); // Mark last element as sorted

            logToSort('selectionSortLog', `Selection Sort Complete. Sorted array: [${arr.join(', ')}]`);
            showSortMessage('selectionSortMessage', 'Selection Sort Complete!', 'success');
            runSelectionSortButton.disabled = false;
            resetSelectionSortButton.disabled = false;
            currentSelectionArray = arr;
        }

        function resetSelectionSort() {
            if (selectionAnimationTimeout) clearTimeout(selectionAnimationTimeout);
            currentSelectionArray = [...initialArrayDefault];
            createBars('selectionSortContainer', currentSelectionArray, Math.max(...initialArrayDefault, 10));
            selectionSortLog.innerHTML = `<p><em>Selection sort reset. Initial array: [${currentSelectionArray.join(', ')}]</em></p>`;
            hideSortMessage('selectionSortMessage');
            runSelectionSortButton.disabled = false;
            resetSelectionSortButton.disabled = false;
        }

        runSelectionSortButton.addEventListener('click', selectionSortVisualize);
        resetSelectionSortButton.addEventListener('click', resetSelectionSort);

        // Initial setup
        resetBubbleSort();
        resetSelectionSort();
    </script>
  </body>
</html>
