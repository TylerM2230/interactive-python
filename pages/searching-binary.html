<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Binary Search: Divide & Conquer | Interactive Python Guide</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/shared-styles.css">
    <style>
      /* Full-page layout matching index.html */
      body {
        margin: 0;
        padding: 0;
        min-height: 100vh;
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
        background-attachment: fixed;
      }

      .console-screen-border {
        min-height: 100vh;
        max-width: none;
        margin: 0;
        padding: 0;
        border: none;
        border-radius: 0;
        background: transparent;
      }

      .content-wrapper-8bit {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 2rem;
      }

      .hero-section {
        background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 50%, #581c87 100%);
        padding: 2rem;
        margin: 0 -2rem 3rem -2rem;
        border-bottom: 3px solid #facc15;
        text-align: center;
        color: #facc15;
        position: relative;
        overflow: hidden;
      }

      .hero-section::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        animation: hero-shimmer 3s infinite;
      }

      @keyframes hero-shimmer {
        0% { left: -100%; }
        100% { left: 100%; }
      }

      .hero-content {
        position: relative;
        z-index: 1;
      }

      .navigation-bar {
        background: rgba(15, 23, 42, 0.9);
        border-bottom: 2px solid #facc15;
        padding: 1rem 0;
        margin-bottom: 2rem;
        backdrop-filter: blur(10px);
        position: sticky;
        top: 0;
        z-index: 100;
      }

      .nav-content {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 2rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 1rem;
      }

      .nav-btn {
        background: linear-gradient(135deg, #1e3a8a, #3730a3);
        color: #facc15;
        padding: 0.5rem 1rem;
        border: 2px solid #facc15;
        border-radius: 6px;
        text-decoration: none;
        font-size: 10px;
        transition: all 0.3s ease;
      }

      .nav-btn:hover {
        background: linear-gradient(135deg, #3730a3, #581c87);
        box-shadow: 0 0 10px rgba(250, 204, 21, 0.5);
        transform: translateY(-2px);
      }

      .concept-section {
        background: rgba(15, 23, 42, 0.3);
        border-radius: 16px;
        padding: 2rem;
        margin-bottom: 2rem;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(250, 204, 21, 0.1);
      }

      .mental-model-box {
        background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(16, 185, 129, 0.1));
        border: 2px solid #10b981;
        border-radius: 12px;
        padding: 1.5rem;
        margin: 1.5rem 0;
        backdrop-filter: blur(10px);
      }

      .pitfall-warning {
        background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(251, 191, 36, 0.1));
        border: 2px solid #f59e0b;
        border-radius: 12px;
        padding: 1.5rem;
        margin: 1.5rem 0;
        backdrop-filter: blur(10px);
      }

      .interactive-repl {
        background: rgba(31, 41, 55, 0.8);
        border: 2px solid #4b5563;
        border-radius: 12px;
        padding: 1.5rem;
        margin: 1.5rem 0;
        backdrop-filter: blur(10px);
      }

      .assessment-section {
        background: rgba(55, 48, 163, 0.2);
        border: 2px solid #3730a3;
        border-radius: 12px;
        padding: 2rem;
        margin: 2rem 0;
        backdrop-filter: blur(10px);
      }

      .search-visualizer {
        background: rgba(15, 23, 42, 0.5);
        border: 2px solid rgba(250, 204, 21, 0.3);
        border-radius: 12px;
        padding: 1.5rem;
        margin: 1.5rem 0;
      }

      .array-container {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 0.5rem;
        margin: 1rem 0;
        flex-wrap: wrap;
      }

      .array-element {
        background: linear-gradient(135deg, #facc15, #f59e0b);
        border: 2px solid #d97706;
        border-radius: 8px;
        padding: 1rem;
        min-width: 50px;
        text-align: center;
        font-weight: bold;
        color: #1f2937;
        transition: all 0.3s ease;
      }

      .array-element.checking {
        background: linear-gradient(135deg, #3b82f6, #2563eb);
        color: white;
        transform: scale(1.1);
        box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
      }

      .array-element.found {
        background: linear-gradient(135deg, #22c55e, #16a34a);
        color: white;
        transform: scale(1.1);
        box-shadow: 0 0 15px rgba(34, 197, 94, 0.5);
      }

      .array-element.eliminated {
        background: linear-gradient(135deg, #6b7280, #4b5563);
        color: #d1d5db;
        opacity: 0.5;
      }

      .quiz-option {
        background: rgba(31, 41, 55, 0.6);
        border: 1px solid #4b5563;
        border-radius: 8px;
        padding: 1rem;
        margin: 0.5rem 0;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .quiz-option:hover {
        border-color: #facc15;
        background: rgba(31, 41, 55, 0.8);
      }

      .quiz-option.correct {
        border-color: #10b981;
        background: rgba(16, 185, 129, 0.2);
      }

      .quiz-option.incorrect {
        border-color: #ef4444;
        background: rgba(239, 68, 68, 0.2);
      }

      .code-highlight {
        background: rgba(250, 204, 21, 0.1);
        border: 1px solid rgba(250, 204, 21, 0.3);
        border-radius: 4px;
        padding: 0.2rem 0.4rem;
        font-family: monospace;
        color: #facc15;
      }

      /* Responsive design */
      @media (max-width: 768px) {
        .content-wrapper-8bit {
          padding: 0 1rem;
        }

        .hero-section {
          padding: 1.5rem 1rem;
          margin: 0 -1rem 2rem -1rem;
        }

        .concept-section {
          padding: 1rem;
        }

        .nav-content {
          flex-direction: column;
          gap: 0.5rem;
        }

        .array-container {
          gap: 0.25rem;
        }

        .array-element {
          min-width: 40px;
          padding: 0.75rem;
          font-size: 14px;
        }
      }
    </style>
  </head>
  <body>
    <div class="console-screen-border">
      <nav class="navigation-bar">
        <div class="nav-content">
          <a href="sorting-merge-joke.html" class="nav-btn">‚Üê Merge Sort</a>
          <div style="flex: 1; text-align: center; color: #facc15; font-size: 10px;">
            Advanced: Binary Search Algorithm
          </div>
          <a href="oop-basics.html" class="nav-btn">Next: OOP Basics ‚Üí</a>
        </div>
      </nav>

      <div class="content-wrapper-8bit">
        <div class="hero-section">
          <div class="hero-content">
            <h1 class="pixel-header">Binary Search</h1>
            <p style="font-size: 12px; margin: 1rem 0; opacity: 0.9;">
              üîç Divide & Conquer: The Art of Intelligent Searching
            </p>
            <div style="background: rgba(250, 204, 21, 0.1); border: 2px dashed #facc15; border-radius: 8px; padding: 1rem; margin: 1rem 0; font-size: 10px;">
              Master logarithmic-time searching in sorted data with the divide-and-conquer strategy
            </div>
          </div>
        </div>

        <main>
          <!-- Core Mental Model Section -->
          <section class="concept-section">
            <h2 class="section-title-8bit">üß† Mental Model: Dictionary Lookup Strategy</h2>
            
            <div class="mental-model-box">
              <h3 style="color: #10b981; margin-bottom: 1rem;">The Dictionary Search</h3>
              <p style="color: #d1fae5; font-size: 11px; line-height: 1.5; margin-bottom: 1rem;">
                Think of looking up a word in a physical dictionary. You don't start from page 1 and read every word! 
                Instead, you open to the middle, see if your word comes before or after, then eliminate half the dictionary. 
                Repeat until found.
              </p>
              <ul style="color: #d1fae5; font-size: 11px; line-height: 1.5; margin-left: 1rem;">
                <li><strong>üéØ Target</strong> - The value you're searching for</li>
                <li><strong>üìç Middle Point</strong> - Check the center of current range</li>
                <li><strong>‚úÇÔ∏è Eliminate Half</strong> - Discard the impossible half</li>
                <li><strong>üîÑ Repeat</strong> - Continue with remaining half until found</li>
              </ul>
            </div>

            <div class="search-visualizer">
              <h3 style="color: #facc15; margin-bottom: 1rem;">üéÆ Interactive Binary Search Visualizer</h3>
              <p style="font-size: 11px; line-height: 1.5; margin-bottom: 1rem;">
                Watch binary search in action! Enter a target value and see how it eliminates half the possibilities each step:
              </p>
              
              <div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 1rem; flex-wrap: wrap;">
                <div>
                  <label style="color: #facc15; font-size: 10px; display: block; margin-bottom: 0.5rem;">Target Value:</label>
                  <input type="number" id="searchTarget" class="input-field" value="42" min="1" max="100" style="width: 100px;">
                </div>
                <button id="startSearch" class="btn">Start Binary Search</button>
                <button id="resetSearch" class="btn">Reset Array</button>
              </div>

              <div style="margin: 1rem 0;">
                <h4 style="color: #facc15; font-size: 12px; margin-bottom: 0.5rem;">Sorted Array:</h4>
                <div id="arrayVisualization" class="array-container">
                  <!-- Array elements will be generated by JavaScript -->
                </div>
              </div>

              <div id="searchOutput" class="output-display" style="margin-top: 1rem;">
                <span class="placeholder-text">Click 'Start Binary Search' to begin the visualization</span>
              </div>
            </div>
          </section>

          <!-- Algorithm Implementation -->
          <section class="concept-section">
            <h2 class="section-title-8bit">‚öôÔ∏è Algorithm Implementation</h2>
            
            <p style="font-size: 11px; line-height: 1.5; margin-bottom: 1.5rem;">
              Binary search works by maintaining three pointers: left, right, and middle. With each comparison, 
              we eliminate half the remaining possibilities, achieving O(log n) time complexity.
            </p>

            <div class="interactive-repl">
              <h3 style="color: #facc15; margin-bottom: 1rem;">Binary Search Implementation</h3>
              
              <pre style="background: #1f2937; padding: 1rem; border-radius: 8px; margin: 1rem 0;"><code>def binary_search(arr, target):
    """
    Search for target in sorted array using binary search.
    Returns index if found, -1 if not found.
    """
    left = 0
    right = len(arr) - 1
    steps = 0
    
    while left <= right:
        steps += 1
        middle = (left + right) // 2
        middle_value = arr[middle]
        
        print(f"Step {steps}: Checking index {middle}, value = {middle_value}")
        
        if middle_value == target:
            print(f"Found {target} at index {middle} in {steps} steps!")
            return middle
        elif middle_value < target:
            print(f"  {middle_value} < {target}, search right half")
            left = middle + 1
        else:
            print(f"  {middle_value} > {target}, search left half")
            right = middle - 1
    
    print(f"Value {target} not found after {steps} steps")
    return -1

# Example usage:
sorted_numbers = [2, 5, 8, 12, 16, 23, 38, 42, 56, 67, 78, 84, 99]
result = binary_search(sorted_numbers, 42)</code></pre>

              <div style="margin: 1rem 0;">
                <label style="color: #facc15; font-size: 11px;">Try it yourself - search for a value:</label>
                <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem; flex-wrap: wrap;">
                  <input type="number" id="manualSearchTarget" class="input-field" value="23" style="width: 100px;">
                  <button id="runManualSearch" class="btn">Run Search</button>
                </div>
              </div>
              
              <div id="manualSearchOutput" class="output-display">
                <span class="placeholder-text">Enter a value and click 'Run Search'</span>
              </div>
            </div>
          </section>

          <!-- Critical Pitfall -->
          <section class="concept-section">
            <h2 class="section-title-8bit">‚ö†Ô∏è Critical Pitfall: Sorted Data Requirement</h2>
            
            <div class="pitfall-warning">
              <h3 style="color: #f59e0b; margin-bottom: 1rem;">Dangerous Assumption: Any Array Can Be Binary Searched</h3>
              <p style="color: #fbbf24; font-size: 11px; line-height: 1.5; margin-bottom: 1rem;">
                <strong>Beginner trap:</strong> Binary search ONLY works on sorted data! Using it on unsorted data 
                will give incorrect results because the algorithm's logic depends on the sorted property.
              </p>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
              <div style="background: rgba(239, 68, 68, 0.2); border: 2px solid #ef4444; border-radius: 8px; padding: 1rem;">
                <h4 style="color: #ef4444; margin-bottom: 0.5rem;">‚ùå Wrong: Unsorted Array</h4>
                <pre style="background: #1f2937; padding: 0.5rem; border-radius: 4px; font-size: 10px;"><code>unsorted = [42, 8, 23, 5, 78, 16, 99]
# Binary search will fail!
# Might miss the target even if it exists</code></pre>
              </div>
              
              <div style="background: rgba(16, 185, 129, 0.2); border: 2px solid #10b981; border-radius: 8px; padding: 1rem;">
                <h4 style="color: #10b981; margin-bottom: 0.5rem;">‚úÖ Correct: Sorted Array</h4>
                <pre style="background: #1f2937; padding: 0.5rem; border-radius: 4px; font-size: 10px;"><code>sorted_array = [5, 8, 16, 23, 42, 78, 99]
# Binary search works perfectly!
# Guaranteed to find target if it exists</code></pre>
              </div>
            </div>

            <div class="mental-model-box" style="margin-top: 1.5rem;">
              <h3 style="color: #10b981; margin-bottom: 0.5rem;">üß† Always Sort First</h3>
              <p style="color: #d1fae5; font-size: 11px; line-height: 1.5;">
                If your data isn't sorted, sort it first with <span class="code-highlight">sorted()</span> or 
                <span class="code-highlight">array.sort()</span>. The O(n log n) sorting cost is often worth it 
                if you'll be searching multiple times.
              </p>
            </div>
          </section>

          <!-- Performance Comparison -->
          <section class="concept-section">
            <h2 class="section-title-8bit">üöÄ Performance: Binary vs Linear Search</h2>
            
            <p style="font-size: 11px; line-height: 1.5; margin-bottom: 1.5rem;">
              Binary search's power becomes clear when comparing it to linear search. The larger the dataset, 
              the more dramatic the difference becomes.
            </p>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
              <div style="background: rgba(239, 68, 68, 0.1); border: 2px solid #ef4444; border-radius: 8px; padding: 1rem;">
                <h4 style="color: #ef4444; margin-bottom: 0.5rem;">üêå Linear Search: O(n)</h4>
                <ul style="color: #fecaca; font-size: 10px; line-height: 1.4; margin-left: 1rem;">
                  <li>1,000 items: up to 1,000 checks</li>
                  <li>1,000,000 items: up to 1,000,000 checks</li>
                  <li>Worst case: check every element</li>
                </ul>
              </div>
              
              <div style="background: rgba(16, 185, 129, 0.1); border: 2px solid #10b981; border-radius: 8px; padding: 1rem;">
                <h4 style="color: #10b981; margin-bottom: 0.5rem;">üöÄ Binary Search: O(log n)</h4>
                <ul style="color: #d1fae5; font-size: 10px; line-height: 1.4; margin-left: 1rem;">
                  <li>1,000 items: max 10 checks</li>
                  <li>1,000,000 items: max 20 checks</li>
                  <li>Eliminates half each step</li>
                </ul>
              </div>
            </div>
          </section>

          <!-- Assessment Section -->
          <section class="assessment-section">
            <h2 style="color: #facc15; margin-bottom: 1.5rem;">üéØ Mastery Check: Binary Search Understanding</h2>
            
            <div style="margin-bottom: 2rem;">
              <h3 style="color: #e5e7eb; margin-bottom: 1rem;">Question 1: Time Complexity</h3>
              <p style="color: #d1d5db; font-size: 11px; margin-bottom: 1rem;">
                What is the time complexity of binary search in the worst case?
              </p>
              
              <div class="quiz-option" data-answer="correct">
                <p style="color: #e5e7eb; font-size: 10px;">O(log n) - logarithmic time</p>
              </div>
              
              <div class="quiz-option" data-answer="incorrect">
                <p style="color: #e5e7eb; font-size: 10px;">O(n) - linear time</p>
              </div>
              
              <div class="quiz-option" data-answer="incorrect">
                <p style="color: #e5e7eb; font-size: 10px;">O(n¬≤) - quadratic time</p>
              </div>
            </div>

            <div style="margin-bottom: 2rem;">
              <h3 style="color: #e5e7eb; margin-bottom: 1rem;">Question 2: Prerequisite</h3>
              <p style="color: #d1d5db; font-size: 11px; margin-bottom: 1rem;">
                What must be true about the data before you can use binary search?
              </p>
              
              <div class="quiz-option" data-answer="correct">
                <p style="color: #e5e7eb; font-size: 10px;">The data must be sorted</p>
              </div>
              
              <div class="quiz-option" data-answer="incorrect">
                <p style="color: #e5e7eb; font-size: 10px;">The data must be unique (no duplicates)</p>
              </div>
              
              <div class="quiz-option" data-answer="incorrect">
                <p style="color: #e5e7eb; font-size: 10px;">The data must be numerical</p>
              </div>
            </div>

            <button id="checkBinaryQuiz" class="btn btn-green">Check My Understanding</button>
            <div id="binaryQuizResult" class="message-box" style="display: none; margin-top: 1rem;"></div>
          </section>

          <!-- Next Steps -->
          <section class="concept-section">
            <h2 class="section-title-8bit">üéØ Ready for Object-Oriented Programming!</h2>
            
            <div class="mental-model-box">
              <h3 style="color: #10b981; margin-bottom: 1rem;">What You've Mastered</h3>
              <ul style="color: #d1fae5; font-size: 11px; line-height: 1.5; margin-left: 1rem;">
                <li>‚úÖ Binary search algorithm and divide-and-conquer strategy</li>
                <li>‚úÖ O(log n) time complexity advantage over linear search</li>
                <li>‚úÖ Critical requirement for sorted data</li>
                <li>‚úÖ Implementation with left, right, and middle pointers</li>
                <li>‚úÖ Performance comparison with linear search</li>
              </ul>
            </div>

            <div style="text-align: center; margin: 2rem 0;">
              <p style="color: #d1d5db; font-size: 11px; margin-bottom: 1rem;">
                Now that you've mastered efficient searching, let's learn how to organize code 
                with classes and objects in Object-Oriented Programming!
              </p>
              <a href="oop-basics.html" class="btn btn-green" style="display: inline-block; padding: 1rem 2rem;">
                Continue to OOP Basics ‚Üí
              </a>
            </div>
          </section>
        </main>

        <footer style="background: rgba(15, 23, 42, 0.8); border-top: 2px solid #facc15; margin-top: 4rem; padding: 2rem 0; text-align: center; backdrop-filter: blur(10px);">
          <p style="color: #facc15; margin-bottom: 0.5rem;">üîç Binary Search Mastered! Ready for OOP? üîç</p>
          <p style="font-size: 10px; color: #9ca3af;">
            <a href="../index.html" style="color: #facc15; margin-right: 1rem;">üè† Back to Main Menu</a>
            <a href="oop-basics.html" style="color: #facc15;">üèóÔ∏è Next: OOP Basics ‚Üí</a>
          </p>
        </footer>
      </div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', function() {
        // Initialize sorted array for visualization
        const sortedArray = [5, 8, 12, 16, 23, 28, 34, 42, 51, 67, 78, 84, 99];
        let searchSteps = [];
        let currentStep = 0;

        function renderArray(highlightIndices = {}) {
          const container = document.getElementById('arrayVisualization');
          container.innerHTML = '';
          
          sortedArray.forEach((value, index) => {
            const element = document.createElement('div');
            element.className = 'array-element';
            element.textContent = value;
            
            if (highlightIndices.checking === index) {
              element.classList.add('checking');
            } else if (highlightIndices.found === index) {
              element.classList.add('found');
            } else if (highlightIndices.eliminated && highlightIndices.eliminated.includes(index)) {
              element.classList.add('eliminated');
            }
            
            container.appendChild(element);
          });
        }

        function binarySearchSteps(arr, target) {
          const steps = [];
          let left = 0;
          let right = arr.length - 1;
          let stepNum = 0;
          
          while (left <= right) {
            stepNum++;
            const middle = Math.floor((left + right) / 2);
            const middleValue = arr[middle];
            
            const eliminatedIndices = [];
            if (middleValue < target) {
              for (let i = left; i <= middle; i++) {
                eliminatedIndices.push(i);
              }
            } else if (middleValue > target) {
              for (let i = middle; i <= right; i++) {
                eliminatedIndices.push(i);
              }
            }
            
            steps.push({
              step: stepNum,
              left, right, middle,
              middleValue,
              target,
              message: `Step ${stepNum}: Checking index ${middle}, value = ${middleValue}`,
              comparison: middleValue === target ? 'found' : 
                         middleValue < target ? 'go right' : 'go left',
              eliminated: eliminatedIndices,
              found: middleValue === target ? middle : null
            });
            
            if (middleValue === target) {
              steps.push({
                step: stepNum + 1,
                message: `Found ${target} at index ${middle} in ${stepNum} steps!`,
                final: true,
                found: middle
              });
              break;
            } else if (middleValue < target) {
              left = middle + 1;
            } else {
              right = middle - 1;
            }
          }
          
          if (left > right && !steps.find(s => s.final)) {
            steps.push({
              step: stepNum + 1,
              message: `Value ${target} not found after ${stepNum} steps`,
              final: true,
              notFound: true
            });
          }
          
          return steps;
        }

        function animateSearch() {
          if (currentStep >= searchSteps.length) {
            return;
          }
          
          const step = searchSteps[currentStep];
          const output = document.getElementById('searchOutput');
          
          if (step.final) {
            if (step.found !== undefined) {
              renderArray({ found: step.found });
              output.innerHTML = `<div style="color: #22c55e; font-weight: bold;">${step.message}</div>`;
            } else {
              renderArray();
              output.innerHTML = `<div style="color: #ef4444; font-weight: bold;">${step.message}</div>`;
            }
            return;
          }
          
          renderArray({ 
            checking: step.middle, 
            eliminated: step.eliminated 
          });
          
          let comparisonText = '';
          if (step.comparison === 'go right') {
            comparisonText = `${step.middleValue} < ${step.target}, search right half`;
          } else if (step.comparison === 'go left') {
            comparisonText = `${step.middleValue} > ${step.target}, search left half`;
          }
          
          output.innerHTML = `
            <div style="color: #facc15; font-weight: bold;">${step.message}</div>
            ${comparisonText ? `<div style="color: #d1d5db; font-size: 10px; margin-top: 0.5rem;">  ${comparisonText}</div>` : ''}
          `;
          
          currentStep++;
          setTimeout(animateSearch, 1500);
        }

        // Event listeners
        document.getElementById('startSearch').addEventListener('click', function() {
          const target = parseInt(document.getElementById('searchTarget').value);
          searchSteps = binarySearchSteps(sortedArray, target);
          currentStep = 0;
          renderArray();
          animateSearch();
        });

        document.getElementById('resetSearch').addEventListener('click', function() {
          currentStep = 0;
          searchSteps = [];
          renderArray();
          document.getElementById('searchOutput').innerHTML = '<span class="placeholder-text">Click \'Start Binary Search\' to begin the visualization</span>';
        });

        // Manual search implementation
        document.getElementById('runManualSearch').addEventListener('click', function() {
          const target = parseInt(document.getElementById('manualSearchTarget').value);
          const output = document.getElementById('manualSearchOutput');
          
          let result = '';
          let left = 0;
          let right = sortedArray.length - 1;
          let steps = 0;
          
          result += `Searching for ${target} in: [${sortedArray.join(', ')}]\n\n`;
          
          while (left <= right) {
            steps++;
            const middle = Math.floor((left + right) / 2);
            const middleValue = sortedArray[middle];
            
            result += `Step ${steps}: Checking index ${middle}, value = ${middleValue}\n`;
            
            if (middleValue === target) {
              result += `Found ${target} at index ${middle} in ${steps} steps!`;
              break;
            } else if (middleValue < target) {
              result += `  ${middleValue} < ${target}, search right half\n`;
              left = middle + 1;
            } else {
              result += `  ${middleValue} > ${target}, search left half\n`;
              right = middle - 1;
            }
          }
          
          if (left > right) {
            result += `Value ${target} not found after ${steps} steps`;
          }
          
          output.textContent = result;
        });

        // Quiz functionality
        const quizOptions = document.querySelectorAll('.quiz-option');
        const checkBinaryQuizBtn = document.getElementById('checkBinaryQuiz');
        const binaryQuizResult = document.getElementById('binaryQuizResult');

        quizOptions.forEach(option => {
          option.addEventListener('click', function() {
            const siblings = this.parentElement.querySelectorAll('.quiz-option');
            siblings.forEach(s => s.style.borderColor = '#4b5563');
            
            this.style.borderColor = '#facc15';
            this.dataset.selected = 'true';
          });
        });

        checkBinaryQuizBtn.addEventListener('click', function() {
          let correct = 0;
          let total = 0;
          
          const questions = document.querySelectorAll('.assessment-section > div');
          questions.forEach(question => {
            const options = question.querySelectorAll('.quiz-option');
            options.forEach(option => {
              if (option.dataset.selected === 'true') {
                total++;
                if (option.dataset.answer === 'correct') {
                  correct++;
                  option.classList.add('correct');
                } else {
                  option.classList.add('incorrect');
                }
              }
            });
          });

          binaryQuizResult.style.display = 'block';
          if (correct === total && total > 0) {
            binaryQuizResult.className = 'message-box message-box-success';
            binaryQuizResult.innerHTML = `üéâ Perfect! ${correct}/${total} correct. You understand binary search algorithm!`;
          } else {
            binaryQuizResult.className = 'message-box message-box-info';
            binaryQuizResult.innerHTML = `${correct}/${total} correct. Review the binary search concepts above, especially the sorted data requirement and logarithmic time complexity!`;
          }
        });

        // Initial render
        renderArray();

        // Progress tracking
        localStorage.setItem('completedBinarySearch', 'true');
      });
    </script>
  </body>
</html> 