<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Binary Search: Divide & Conquer | Interactive Python Guide</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/shared-styles.css">
  </head>
  <body class="page-layout">
    <div class="page-console-border">
      <div class="lesson-hero">
        <div class="lesson-hero-content">
          <h1 class="lesson-title">
            <a href="../index.html" style="color: inherit; text-decoration: none;">Interactive Guide to Python</a>
          </h1>
          <h2 class="lesson-subtitle">Binary Search: Divide & Conquer</h2>
          <p class="lesson-subtitle">
            Efficient Searching ‚Ä¢ Logarithmic Complexity ‚Ä¢ Sorted Data
          </p>
        </div>
      </div>

      <nav class="page-navigation">
        <div class="nav-content">
          <a href="sorting-merge-joke.html" class="nav-btn">‚Üê Advanced Sorting</a>
          <a href="../index.html" class="nav-btn">üè† Home</a>
          <a href="oop-basics.html" class="nav-btn">OOP Basics ‚Üí</a>
        </div>
      </nav>

      <main class="page-content-wrapper">
        <!-- Core Mental Model Section -->
        <section class="concept-section">
          <h2 class="section-title-8bit">üß† Mental Model: Dictionary Lookup Strategy</h2>
          
          <div class="mental-model-box">
            <h3 style="color: #10b981; margin-bottom: 1rem;">The Dictionary Search</h3>
            <p style="color: #d1fae5; font-size: 11px; line-height: 1.5; margin-bottom: 1rem;">
              Think of looking up a word in a physical dictionary. You don't start from page 1 and read every word! 
              Instead, you open to the middle, see if your word comes before or after, then eliminate half the dictionary. 
              Repeat until found.
            </p>
            <ul style="color: #d1fae5; font-size: 11px; line-height: 1.5; margin-left: 1rem;">
              <li><strong>üéØ Target</strong> - The value you're searching for</li>
              <li><strong>üìç Middle Point</strong> - Check the center of current range</li>
              <li><strong>‚úÇÔ∏è Eliminate Half</strong> - Discard the impossible half</li>
              <li><strong>üîÑ Repeat</strong> - Continue with remaining half until found</li>
            </ul>
          </div>

          <div class="search-visualizer">
            <h3 style="color: #facc15; margin-bottom: 1rem;">üéÆ Interactive Binary Search Visualizer</h3>
            <p style="font-size: 11px; line-height: 1.5; margin-bottom: 1rem;">
              Watch binary search in action! Enter a target value and see how it eliminates half the possibilities each step:
            </p>
            
            <div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 1rem; flex-wrap: wrap;">
              <div>
                <label style="color: #facc15; font-size: 10px; display: block; margin-bottom: 0.5rem;">Target Value:</label>
                <input type="number" id="searchTarget" class="input-field" value="42" min="1" max="100" style="width: 100px;">
              </div>
              <button id="startSearch" class="btn">Start Binary Search</button>
              <button id="resetSearch" class="btn">Reset Array</button>
            </div>

            <div style="margin: 1rem 0;">
              <h4 style="color: #facc15; font-size: 12px; margin-bottom: 0.5rem;">Sorted Array:</h4>
              <div id="arrayVisualization" class="array-container">
                <!-- Array elements will be generated by JavaScript -->
              </div>
            </div>

            <div id="searchOutput" class="output-display" style="margin-top: 1rem;">
              <span class="placeholder-text">Click 'Start Binary Search' to begin the visualization</span>
            </div>
          </div>
        </section>

        <!-- Algorithm Implementation -->
        <section class="concept-section">
          <h2 class="section-title-8bit">‚öôÔ∏è Algorithm Implementation</h2>
          
          <p style="font-size: 11px; line-height: 1.5; margin-bottom: 1.5rem;">
            Binary search works by maintaining three pointers: left, right, and middle. With each comparison, 
            we eliminate half the remaining possibilities, achieving O(log n) time complexity.
          </p>

          <div class="interactive-repl">
            <h3 style="color: #facc15; margin-bottom: 1rem;">Binary Search Implementation</h3>
            
            <pre style="background: #1f2937; padding: 1rem; border-radius: 8px; margin: 1rem 0;"><code>def binary_search(arr, target):
    """
    Search for target in sorted array using binary search.
    Returns index if found, -1 if not found.
    """
    left = 0
    right = len(arr) - 1
    steps = 0
    
    while left <= right:
        steps += 1
        middle = (left + right) // 2
        middle_value = arr[middle]
        
        print(f"Step {steps}: Checking index {middle}, value = {middle_value}")
        
        if middle_value == target:
            print(f"Found {target} at index {middle} in {steps} steps!")
            return middle
        elif middle_value < target:
            print(f"  {middle_value} < {target}, search right half")
            left = middle + 1
        else:
            print(f"  {middle_value} > {target}, search left half")
            right = middle - 1
    
    print(f"Value {target} not found after {steps} steps")
    return -1

# Example usage:
sorted_numbers = [2, 5, 8, 12, 16, 23, 38, 42, 56, 67, 78, 84, 99]
result = binary_search(sorted_numbers, 42)</code></pre>

            <div style="margin: 1rem 0;">
              <label style="color: #facc15; font-size: 11px;">Try it yourself - search for a value:</label>
              <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem; flex-wrap: wrap;">
                <input type="number" id="manualSearchTarget" class="input-field" value="23" style="width: 100px;">
                <button id="runManualSearch" class="btn">Run Search</button>
              </div>
            </div>
            
            <div id="manualSearchOutput" class="output-display">
              <span class="placeholder-text">Enter a value and click 'Run Search'</span>
            </div>
          </div>
        </section>

        <!-- Critical Pitfall -->
        <section class="concept-section">
          <h2 class="section-title-8bit">‚ö†Ô∏è Critical Pitfall: Sorted Data Requirement</h2>
          
          <div class="pitfall-warning">
            <h3 style="color: #f59e0b; margin-bottom: 1rem;">Dangerous Assumption: Any Array Can Be Binary Searched</h3>
            <p style="color: #fbbf24; font-size: 11px; line-height: 1.5; margin-bottom: 1rem;">
              <strong>Beginner trap:</strong> Binary search ONLY works on sorted data! Using it on unsorted data 
              will give incorrect results because the algorithm's logic depends on the sorted property.
            </p>
          </div>

          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
            <div style="background: rgba(239, 68, 68, 0.2); border: 2px solid #ef4444; border-radius: 8px; padding: 1rem;">
              <h4 style="color: #ef4444; margin-bottom: 0.5rem;">‚ùå Wrong: Unsorted Array</h4>
              <pre style="background: #1f2937; padding: 0.5rem; border-radius: 4px; font-size: 10px;"><code>unsorted = [42, 8, 23, 5, 78, 16, 99]
# Binary search will fail!
# Might miss the target even if it exists</code></pre>
            </div>
            
            <div style="background: rgba(16, 185, 129, 0.2); border: 2px solid #10b981; border-radius: 8px; padding: 1rem;">
              <h4 style="color: #10b981; margin-bottom: 0.5rem;">‚úÖ Correct: Sorted Array</h4>
              <pre style="background: #1f2937; padding: 0.5rem; border-radius: 4px; font-size: 10px;"><code>sorted_array = [5, 8, 16, 23, 42, 78, 99]
# Binary search works perfectly!
# Guaranteed to find target if it exists</code></pre>
            </div>
          </div>

          <div class="mental-model-box" style="margin-top: 1.5rem;">
            <h3 style="color: #10b981; margin-bottom: 0.5rem;">üß† Always Sort First</h3>
            <p style="color: #d1fae5; font-size: 11px; line-height: 1.5;">
              If your data isn't sorted, sort it first with <span class="code-highlight">sorted()</span> or 
              <span class="code-highlight">array.sort()</span>. The O(n log n) sorting cost is often worth it 
              if you'll be searching multiple times.
            </p>
          </div>
        </section>

        <!-- Performance Comparison -->
        <section class="concept-section">
          <h2 class="section-title-8bit">üöÄ Performance: Binary vs Linear Search</h2>
          
          <p style="font-size: 11px; line-height: 1.5; margin-bottom: 1.5rem;">
            Binary search's power becomes clear when comparing it to linear search. The larger the dataset, 
            the more dramatic the difference becomes.
          </p>

          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
            <div style="background: rgba(239, 68, 68, 0.1); border: 2px solid #ef4444; border-radius: 8px; padding: 1rem;">
              <h4 style="color: #ef4444; margin-bottom: 0.5rem;">üêå Linear Search: O(n)</h4>
              <ul style="color: #fecaca; font-size: 10px; line-height: 1.4; margin-left: 1rem;">
                <li>1,000 items: up to 1,000 checks</li>
                <li>1,000,000 items: up to 1,000,000 checks</li>
                <li>Worst case: check every element</li>
              </ul>
            </div>
            
            <div style="background: rgba(16, 185, 129, 0.1); border: 2px solid #10b981; border-radius: 8px; padding: 1rem;">
              <h4 style="color: #10b981; margin-bottom: 0.5rem;">üöÄ Binary Search: O(log n)</h4>
              <ul style="color: #d1fae5; font-size: 10px; line-height: 1.4; margin-left: 1rem;">
                <li>1,000 items: max 10 checks</li>
                <li>1,000,000 items: max 20 checks</li>
                <li>Eliminates half each step</li>
              </ul>
            </div>
          </div>
        </section>

        <!-- Assessment Section -->
        <section class="assessment-section">
          <h2 style="color: #facc15; margin-bottom: 1.5rem;">üéØ Mastery Check: Binary Search Understanding</h2>
          
          <div style="margin-bottom: 2rem;">
            <h3 style="color: #e5e7eb; margin-bottom: 1rem;">Question 1: Time Complexity</h3>
            <p style="color: #d1d5db; font-size: 11px; margin-bottom: 1rem;">
              What is the time complexity of binary search in the worst case?
            </p>
            
            <div class="quiz-option" data-answer="correct">
              <p style="color: #e5e7eb; font-size: 10px;">O(log n) - logarithmic time</p>
            </div>
            
            <div class="quiz-option" data-answer="incorrect">
              <p style="color: #e5e7eb; font-size: 10px;">O(n) - linear time</p>
            </div>
            
            <div class="quiz-option" data-answer="incorrect">
              <p style="color: #e5e7eb; font-size: 10px;">O(n¬≤) - quadratic time</p>
            </div>
          </div>

          <div style="margin-bottom: 2rem;">
            <h3 style="color: #e5e7eb; margin-bottom: 1rem;">Question 2: Prerequisite</h3>
            <p style="color: #d1d5db; font-size: 11px; margin-bottom: 1rem;">
              What must be true about the data before you can use binary search?
            </p>
            
            <div class="quiz-option" data-answer="correct">
              <p style="color: #e5e7eb; font-size: 10px;">The data must be sorted</p>
            </div>
            
            <div class="quiz-option" data-answer="incorrect">
              <p style="color: #e5e7eb; font-size: 10px;">The data must be unique (no duplicates)</p>
            </div>
            
            <div class="quiz-option" data-answer="incorrect">
              <p style="color: #e5e7eb; font-size: 10px;">The data must be numerical</p>
            </div>
          </div>

          <button id="checkBinaryQuiz" class="btn btn-green">Check My Understanding</button>
          <div id="binaryQuizResult" class="message-box" style="display: none; margin-top: 1rem;"></div>
        </section>

        <!-- Next Steps -->
        <section class="concept-section">
          <h2 class="section-title-8bit">üéØ Ready for Object-Oriented Programming!</h2>
          
          <div class="mental-model-box">
            <h3 style="color: #10b981; margin-bottom: 1rem;">What You've Mastered</h3>
            <ul style="color: #d1fae5; font-size: 11px; line-height: 1.5; margin-left: 1rem;">
              <li>‚úÖ Binary search algorithm and divide-and-conquer strategy</li>
              <li>‚úÖ O(log n) time complexity advantage over linear search</li>
              <li>‚úÖ Critical requirement for sorted data</li>
              <li>‚úÖ Implementation with left, right, and middle pointers</li>
              <li>‚úÖ Performance comparison with linear search</li>
            </ul>
          </div>

          <div style="text-align: center; margin: 2rem 0;">
            <p style="color: #d1d5db; font-size: 11px; margin-bottom: 1rem;">
              Now that you've mastered efficient searching, let's learn how to organize code 
              with classes and objects in Object-Oriented Programming!
            </p>
            <a href="oop-basics.html" class="btn btn-green" style="display: inline-block; padding: 1rem 2rem;">
              Continue to OOP Basics ‚Üí
            </a>
          </div>
        </section>
      </main>

      <footer style="background: rgba(15, 23, 42, 0.8); border-top: 2px solid #facc15; margin-top: 4rem; padding: 2rem 0; text-align: center; backdrop-filter: blur(10px);">
        <p style="color: #facc15; margin-bottom: 0.5rem;">üîç Binary Search Mastered! Ready for OOP? üîç</p>
        <p style="font-size: 10px; color: #9ca3af;">
          <a href="../index.html" style="color: #facc15; margin-right: 1rem;">üè† Back to Main Menu</a>
          <a href="oop-basics.html" style="color: #facc15;">üèóÔ∏è Next: OOP Basics ‚Üí</a>
        </p>
      </footer>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', function() {
        // Initialize sorted array for visualization
        const sortedArray = [5, 8, 12, 16, 23, 28, 34, 42, 51, 67, 78, 84, 99];
        let searchSteps = [];
        let currentStep = 0;

        function renderArray(highlightIndices = {}) {
          const container = document.getElementById('arrayVisualization');
          container.innerHTML = '';
          
          sortedArray.forEach((value, index) => {
            const element = document.createElement('div');
            element.className = 'array-element';
            element.textContent = value;
            
            if (highlightIndices.checking === index) {
              element.classList.add('checking');
            } else if (highlightIndices.found === index) {
              element.classList.add('found');
            } else if (highlightIndices.eliminated && highlightIndices.eliminated.includes(index)) {
              element.classList.add('eliminated');
            }
            
            container.appendChild(element);
          });
        }

        function binarySearchSteps(arr, target) {
          const steps = [];
          let left = 0;
          let right = arr.length - 1;
          let stepNum = 0;
          
          while (left <= right) {
            stepNum++;
            const middle = Math.floor((left + right) / 2);
            const middleValue = arr[middle];
            
            const eliminatedIndices = [];
            if (middleValue < target) {
              for (let i = left; i <= middle; i++) {
                eliminatedIndices.push(i);
              }
            } else if (middleValue > target) {
              for (let i = middle; i <= right; i++) {
                eliminatedIndices.push(i);
              }
            }
            
            steps.push({
              step: stepNum,
              left, right, middle,
              middleValue,
              target,
              message: `Step ${stepNum}: Checking index ${middle}, value = ${middleValue}`,
              comparison: middleValue === target ? 'found' : 
                         middleValue < target ? 'go right' : 'go left',
              eliminated: eliminatedIndices,
              found: middleValue === target ? middle : null
            });
            
            if (middleValue === target) {
              steps.push({
                step: stepNum + 1,
                message: `Found ${target} at index ${middle} in ${stepNum} steps!`,
                final: true,
                found: middle
              });
              break;
            } else if (middleValue < target) {
              left = middle + 1;
            } else {
              right = middle - 1;
            }
          }
          
          if (left > right && !steps.find(s => s.final)) {
            steps.push({
              step: stepNum + 1,
              message: `Value ${target} not found after ${stepNum} steps`,
              final: true,
              notFound: true
            });
          }
          
          return steps;
        }

        function animateSearch() {
          if (currentStep >= searchSteps.length) {
            return;
          }
          
          const step = searchSteps[currentStep];
          const output = document.getElementById('searchOutput');
          
          if (step.final) {
            if (step.found !== undefined) {
              renderArray({ found: step.found });
              output.innerHTML = `<div style="color: #22c55e; font-weight: bold;">${step.message}</div>`;
            } else {
              renderArray();
              output.innerHTML = `<div style="color: #ef4444; font-weight: bold;">${step.message}</div>`;
            }
            return;
          }
          
          renderArray({ 
            checking: step.middle, 
            eliminated: step.eliminated 
          });
          
          let comparisonText = '';
          if (step.comparison === 'go right') {
            comparisonText = `${step.middleValue} < ${step.target}, search right half`;
          } else if (step.comparison === 'go left') {
            comparisonText = `${step.middleValue} > ${step.target}, search left half`;
          }
          
          output.innerHTML = `
            <div style="color: #facc15; font-weight: bold;">${step.message}</div>
            ${comparisonText ? `<div style="color: #d1d5db; font-size: 10px; margin-top: 0.5rem;">  ${comparisonText}</div>` : ''}
          `;
          
          currentStep++;
          setTimeout(animateSearch, 1500);
        }

        // Event listeners
        document.getElementById('startSearch').addEventListener('click', function() {
          const target = parseInt(document.getElementById('searchTarget').value);
          searchSteps = binarySearchSteps(sortedArray, target);
          currentStep = 0;
          renderArray();
          animateSearch();
        });

        document.getElementById('resetSearch').addEventListener('click', function() {
          currentStep = 0;
          searchSteps = [];
          renderArray();
          document.getElementById('searchOutput').innerHTML = '<span class="placeholder-text">Click \'Start Binary Search\' to begin the visualization</span>';
        });

        // Manual search implementation
        document.getElementById('runManualSearch').addEventListener('click', function() {
          const target = parseInt(document.getElementById('manualSearchTarget').value);
          const output = document.getElementById('manualSearchOutput');
          
          let result = '';
          let left = 0;
          let right = sortedArray.length - 1;
          let steps = 0;
          
          result += `Searching for ${target} in: [${sortedArray.join(', ')}]\n\n`;
          
          while (left <= right) {
            steps++;
            const middle = Math.floor((left + right) / 2);
            const middleValue = sortedArray[middle];
            
            result += `Step ${steps}: Checking index ${middle}, value = ${middleValue}\n`;
            
            if (middleValue === target) {
              result += `Found ${target} at index ${middle} in ${steps} steps!`;
              break;
            } else if (middleValue < target) {
              result += `  ${middleValue} < ${target}, search right half\n`;
              left = middle + 1;
            } else {
              result += `  ${middleValue} > ${target}, search left half\n`;
              right = middle - 1;
            }
          }
          
          if (left > right) {
            result += `Value ${target} not found after ${steps} steps`;
          }
          
          output.textContent = result;
        });

        // Quiz functionality
        const quizOptions = document.querySelectorAll('.quiz-option');
        const checkBinaryQuizBtn = document.getElementById('checkBinaryQuiz');
        const binaryQuizResult = document.getElementById('binaryQuizResult');

        quizOptions.forEach(option => {
          option.addEventListener('click', function() {
            const siblings = this.parentElement.querySelectorAll('.quiz-option');
            siblings.forEach(s => s.style.borderColor = '#4b5563');
            
            this.style.borderColor = '#facc15';
            this.dataset.selected = 'true';
          });
        });

        checkBinaryQuizBtn.addEventListener('click', function() {
          let correct = 0;
          let total = 0;
          
          const questions = document.querySelectorAll('.assessment-section > div');
          questions.forEach(question => {
            const options = question.querySelectorAll('.quiz-option');
            options.forEach(option => {
              if (option.dataset.selected === 'true') {
                total++;
                if (option.dataset.answer === 'correct') {
                  correct++;
                  option.classList.add('correct');
                } else {
                  option.classList.add('incorrect');
                }
              }
            });
          });

          binaryQuizResult.style.display = 'block';
          if (correct === total && total > 0) {
            binaryQuizResult.className = 'message-box message-box-success';
            binaryQuizResult.innerHTML = `üéâ Perfect! ${correct}/${total} correct. You understand binary search algorithm!`;
          } else {
            binaryQuizResult.className = 'message-box message-box-info';
            binaryQuizResult.innerHTML = `${correct}/${total} correct. Review the binary search concepts above, especially the sorted data requirement and logarithmic time complexity!`;
          }
        });

        // Initial render
        renderArray();

        // Progress tracking
        localStorage.setItem('completedBinarySearch', 'true');
      });
    </script>
  </body>
</html> 