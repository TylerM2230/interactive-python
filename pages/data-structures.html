<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Data Structures Overview (Sets, Stacks, Queues)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/shared-styles.css">
  </head>
  <body class="bg-blue-700 text-gray-300 p-4 md:p-8">
    <header class="text-center mb-8">
      <a href="../index.html" class="text-3xl md:text-4xl font-bold text-yellow-300 hover:text-yellow-200 transition-colors duration-200">
        Interactive Guide to Python
      </a>
      <h1 class="text-2xl md:text-3xl font-semibold text-yellow-400 mt-2">
        Data Structures Overview (Sets, Stacks, Queues)
      </h1>
      <p class="text-xs text-cyan-500 mt-1 italic">
        Exploring fundamental ways to organize and store data, including Sets, Stacks, and Queues.
      </p>
    </header>

    <nav
      class="max-w-4xl mx-auto mb-6 p-3 bg-blue-800 rounded-lg shadow-md flex justify-between items-center"
    >
      <a href="dictionaries-tuples.html"
        class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition-colors duration-200">
        &larr; Previous: Dictionaries & Tuples
      </a>
      <a href="trees.html"
        class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition-colors duration-200">
        Next: Trees (BST) &rarr;
      </a>
    </nav>

    <main class="max-w-4xl mx-auto">
      <section class="mb-8">
        <h2 class="text-2xl font-semibold text-yellow-300 mb-3">
          1. Why Data Structures?
        </h2>
        <p class="mb-4">
          Data structures are specialized formats for **organizing, processing,
          retrieving, and storing data**. Just like you might organize clothes
          in a dresser or books on a shelf, data structures provide ways to
          arrange data in a computer's memory efficiently. Think of them as different types of containers, each designed for specific purposes - just as you wouldn't use a shoebox to store liquids, you wouldn't use a stack for random access to data.
        </p>
        <p>
          Choosing the right data structure is crucial because it can
          significantly impact:
        </p>
        <ul class="list-disc list-inside ml-4 space-y-1">
          <li>
            <strong>Efficiency:</strong> How quickly operations like adding,
            removing, or searching for data can be performed.
          </li>
          <li>
            <strong>Memory Usage:</strong> How much space the data takes up.
          </li>
          <li>
            <strong>Code Clarity:</strong> How easy it is to work with the data
            and understand the code.
          </li>
        </ul>
        <p class="mt-2">
          Different data structures are suited for different kinds of problems.
        </p>
      </section>

      <section class="mb-8">
        <h2 class="text-2xl font-semibold text-yellow-300 mb-3">
          2. Sets: Unordered Collections of Unique Items
        </h2>
        <p class="mb-2">
          A set is an **unordered collection of unique items**. Think of it like
          a mathematical set, or more practically, like a collection of unique trading cards - you can't have duplicates, and the order doesn't matter when you're just checking if you have a particular card.
        </p>
        <p class="mb-2">Key characteristics:</p>
        <ul class="list-disc list-inside ml-4 space-y-1">
          <li>
            <strong>Unordered:</strong> Items don't have a specific position or
            index.
          </li>
          <li>
            <strong>Unique Elements:</strong> Duplicate items are automatically
            removed.
          </li>
          <li>
            <strong>Mutable:</strong> You can add or remove elements after
            creation.
          </li>
          <li>
            <strong>Fast Membership Testing:</strong> Very efficient for
            checking if an item exists within the set (<code>in</code>
            operator).
          </li>
        </ul>
        <h3 class="text-lg font-medium text-cyan-400 mt-4 mb-1">Common Set Operations:</h3>
        <pre><code class="language-python">set1 = {1, 2, 3}
set2 = {3, 4, 5}

# Union: items present in either set
print(f"Union: {set1 | set2}") # Output: {1, 2, 3, 4, 5}

# Intersection: items present in both sets
print(f"Intersection: {set1 & set2}") # Output: {3}

# Difference: items in set1 but not in set2
print(f"Difference (set1 - set2): {set1 - set2}") # Output: {1, 2}

# Symmetric Difference: items in either set, but not both
print(f"Symmetric Difference: {set1 ^ set2}") # Output: {1, 2, 4, 5}</code></pre>
      </section>

      <section class="interactive-section mb-8">
        <h2 class="text-2xl font-semibold text-yellow-300 mb-3">
          Interactive: Try Set Operations
        </h2>
        <p class="mb-2">Enter comma-separated numbers for two sets (e.g., 1,2,3).</p>
        <div class="flex flex-wrap items-center mb-2">
          <label for="setInput1" class="mr-2">Set 1:</label>
          <input
            type="text"
            id="setInput1"
            class="input-field"
            placeholder="e.g., 1,2,3"
          />
        </div>
        <div class="flex flex-wrap items-center mb-2">
          <label for="setInput2" class="mr-2">Set 2:</label>
          <input
            type="text"
            id="setInput2"
            class="input-field"
            placeholder="e.g., 3,4,5"
          />
        </div>
        <button id="calculateSetOperationsButton" class="btn btn-green">Calculate Operations</button>
        <div id="setOperationsResult" class="output-display">
          <span class="text-gray-500 italic">Results will appear here.</span>
        </div>
      </section>

      <section class="mb-8">
        <h2 class="text-2xl font-semibold text-yellow-300 mb-3">
          3. Stacks: Last-In, First-Out (LIFO)
        </h2>
        <p class="mb-2">
          A stack is a linear data structure that follows the **Last-In,
          First-Out (LIFO)** principle. Think of a stack of plates: the last
          plate you put on top is the first one you take off. It's like a PEZ candy dispenser - you can only access the candy that was most recently loaded, and you have to remove that one before getting to the ones below it.
        </p>
        <p class="mb-2">Main operations:</p>
        <ul class="list-disc list-inside ml-4 space-y-1">
          <li><strong>Push:</strong> Add an item to the top of the stack.</li>
          <li>
            <strong>Pop:</strong> Remove and return the item from the top of the
            stack.
          </li>
          <li>
            <strong>Peek (or Top):</strong> View the top item without removing
            it.
          </li>
        </ul>
        <p class="mt-2 text-sm text-gray-600">
          In Python, lists can be easily used to implement stacks, using
          <code>append()</code> for push and <code>pop()</code> (without an
          index) for pop. It's like having a stack of papers on your desk - you can only work with the top paper, and new papers go on top.
        </p>
        <pre><code class="language-python">my_stack = []

# Push items
my_stack.append('A')
my_stack.append('B')
my_stack.append('C')
print(f"Stack after pushes: {my_stack}") # Output: ['A', 'B', 'C']

# Peek (view top item)
top_item = my_stack[-1]
print(f"Top item (peek): {top_item}") # Output: C

# Pop item
removed_item = my_stack.pop()
print(f"Popped item: {removed_item}") # Output: C
print(f"Stack after pop: {my_stack}") # Output: ['A', 'B']</code></pre>
      </section>

      <section class="interactive-section mb-8">
        <h2 class="text-2xl font-semibold text-yellow-300 mb-3">
          Interactive: Stack Simulation (LIFO)
        </h2>
        <div class="flex flex-wrap items-center gap-2 mb-4">
          <label for="stackItemInput" class="mr-2">Item to Push:</label>
          <input
            type="text"
            id="stackItemInput"
            class="input-field"
            placeholder="e.g., X"
          />
          <button id="pushButton" class="btn btn-green">Push onto Stack</button>
          <button id="popButton" class="btn btn-red">Pop from Stack</button>
          <button id="peekStackButton" class="btn">Peek Top</button>
        </div>
        <h4 class="text-md font-medium mt-3 mb-1">
          Current Stack (Top is Up):
        </h4>
        <div
          id="stackContainer"
          class="data-structure-container stack-container"
        ></div>
        <div id="stackResultDisplay" class="output-display">
          <span class="text-gray-500 italic">Perform an operation.</span>
        </div>
        <div id="stackMessage" class="message-box" style="display: none"></div>
      </section>

      <section class="mb-8">
        <h2 class="text-2xl font-semibold text-yellow-300 mb-3">
          4. Queues: First-In, First-Out (FIFO)
        </h2>
        <p class="mb-2">
          A queue is a linear data structure that follows the **First-In,
          First-Out (FIFO)** principle. Think of a queue or line for a checkout:
          the first person in line is the first person served. It's like a printer queue - documents are printed in the order they were sent, and you can't jump ahead of others who sent their documents first.
        </p>
        <p class="mb-2">Main operations:</p>
        <ul class="list-disc list-inside ml-4 space-y-1">
          <li>
            <strong>Enqueue:</strong> Add an item to the rear (end) of the
            queue.
          </li>
          <li>
            <strong>Dequeue:</strong> Remove and return the item from the front
            of the queue.
          </li>
          <li>
            <strong>Peek (or Front):</strong> View the front item without
            removing it.
          </li>
        </ul>
        <p class="mt-2 text-sm text-gray-600">
          While lists can be used, popping from the beginning of a list
          (<code>list.pop(0)</code>) is inefficient (O(n)). Python's
          <code>collections.deque</code> (double-ended queue) is optimized for
          fast appends and pops from both ends, making it ideal for implementing
          queues. Think of it like a conveyor belt at a factory - items can be added or removed from either end efficiently, unlike a traditional list which is more like a line of people where removing someone from the front requires everyone to step forward.
        </p>
        <h3 class="text-lg font-medium text-cyan-400 mt-4 mb-1">Implementing a Queue with `collections.deque`:</h3>
        <pre><code class="language-python">from collections import deque

my_queue = deque()

# Enqueue (add to the right)
my_queue.append("Alice")
my_queue.append("Bob")
my_queue.append("Charlie")
print(f"Queue after enqueuing: {my_queue}")

# Dequeue (remove from the left)
first_person = my_queue.popleft()
print(f"Dequeued: {first_person}")
print(f"Queue after dequeuing: {my_queue}")

# Peek (view the front element)
if my_queue:
  print(f"Front of queue: {my_queue[0]}")</code></pre>
      </section>

      <section class="interactive-section mb-8">
        <h2 class="text-2xl font-semibold text-yellow-300 mb-3">
          Interactive: Queue Simulation (FIFO)
        </h2>
        <div class="flex flex-wrap items-center gap-2 mb-4">
          <label for="queueItemInput" class="mr-2">Item to Enqueue:</label>
          <input
            type="text"
            id="queueItemInput"
            class="input-field"
            placeholder="e.g., P1"
          />
          <button id="enqueueButton" class="btn btn-green">
            Enqueue (Add Rear)
          </button>
          <button id="dequeueButton" class="btn btn-red">
            Dequeue (Remove Front)
          </button>
          <button id="peekQueueButton" class="btn">Peek Front</button>
        </div>
        <h4 class="text-md font-medium mt-3 mb-1">
          Current Queue (Front is Left):
        </h4>
        <div
          id="queueContainer"
          class="data-structure-container queue-container"
        ></div>
        <div id="queueResultDisplay" class="output-display">
          <span class="text-gray-500 italic">Perform an operation.</span>
        </div>
        <div id="queueMessage" class="message-box" style="display: none"></div>
      </section>

      <section class="mb-8">
        <h2 class="text-2xl font-semibold text-yellow-300 mb-3">
          5. Other Important Data Structures (Briefly)
        </h2>
        <p class="mb-2">Beyond the basics, other important structures exist:</p>
        <ul class="list-disc list-inside ml-4 space-y-2 text-sm">
          <li>
            <strong>Linked Lists:</strong> Linear collections where elements
            (nodes) are linked using pointers, rather than being stored
            contiguously in memory like lists/arrays. Think of it like a treasure hunt where each clue points to the location of the next clue. This structure allows efficient
            insertions/deletions in the middle but slower access by index.
          </li>
          <li>
            <strong>Trees:</strong> Hierarchical structures with a root node and
            child nodes branching out. Like a family tree or an organizational chart, where each person (node) can have multiple children but only one parent. Used for representing hierarchies (file
            systems), efficient searching (Binary Search Trees), and more.
          </li>
          <li>
            <strong>Graphs:</strong> Collections of nodes (vertices) connected
            by edges. Think of a social network where people (nodes) are connected by friendships (edges), or a map where cities (nodes) are connected by roads (edges). Used to model networks (social networks, road maps,
            computer networks).
          </li>
          <li>
            <strong>Hash Tables (underlying Dictionaries):</strong> Use a hash
            function to map keys to indices in an array, providing very fast
            average-case lookups, insertions, and deletions. It's like having a library's card catalog system - you can quickly find a book by looking up its unique identifier, rather than searching through every shelf.
          </li>
        </ul>
      </section>

      <section class="mb-8 interactive-section">
        <h2 class="text-2xl font-semibold text-yellow-300 mb-3">7. Quick Quiz</h2>
        <p class="mb-4">Test your understanding!</p>
        <div class="mb-3">
          <p class="font-medium mb-1">
            Q1: Which data structure guarantees that all its elements are
            unique?
          </p>
          <label class="block"
            ><input type="radio" name="q1_ds" value="a" class="mr-1" />
            List</label
          >
          <label class="block"
            ><input type="radio" name="q1_ds" value="b" class="mr-1" />
            Set</label
          >
          <label class="block"
            ><input type="radio" name="q1_ds" value="c" class="mr-1" />
            Tuple</label
          >
        </div>
        <div class="mb-3">
          <p class="font-medium mb-1">
            Q2: What does LIFO stand for, and which structure follows it?
          </p>
          <label class="block"
            ><input type="radio" name="q2_ds" value="a" class="mr-1" /> Last-In,
            First-Out (Queue)</label
          >
          <label class="block"
            ><input type="radio" name="q2_ds" value="b" class="mr-1" />
            First-In, First-Out (Stack)</label
          >
          <label class="block"
            ><input type="radio" name="q2_ds" value="c" class="mr-1" /> Last-In,
            First-Out (Stack)</label
          >
        </div>
        <div class="mb-3">
          <p class="font-medium mb-1">
            Q3: Adding an element to the end of a queue is called:
          </p>
          <label class="block"
            ><input type="radio" name="q3_ds" value="a" class="mr-1" />
            Push</label
          >
          <label class="block"
            ><input type="radio" name="q3_ds" value="b" class="mr-1" />
            Enqueue</label
          >
          <label class="block"
            ><input type="radio" name="q3_ds" value="c" class="mr-1" />
            Append</label
          >
        </div>
        <div class="mb-3">
          <p class="font-medium mb-1">
            Q4: Which Python collection type is generally best suited for
            implementing an efficient queue?
          </p>
          <label class="block"
            ><input type="radio" name="q4_ds" value="a" class="mr-1" />
            `list`</label
          >
          <label class="block"
            ><input type="radio" name="q4_ds" value="b" class="mr-1" />
            `tuple`</label
          >
          <label class="block"
            ><input type="radio" name="q4_ds" value="c" class="mr-1" />
            `collections.deque`</label
          >
        </div>
        <button id="checkQuizButtonDS" class="btn">Check Answers</button>
        <div
          id="quizResultDS"
          class="message-box mt-4"
          style="display: none"
        ></div>
      </section>
    </main>

    <footer class="text-center mt-12 py-6 border-t border-yellow-500">
      <p class="text-sm text-cyan-300">Happy Coding!</p>
      <p class="mt-2">
        <a
          href="../index.html"
          class="text-yellow-400 hover:text-yellow-200 font-medium transition-colors duration-200"
          >Back to Main Menu</a
        >
      </p>
    </footer>

    <script src="../js/main.js" defer></script>
    <script>
      // showMessage is now in js/main.js

      // --- DOM Elements ---
      const setInput1 = document.getElementById("setInput1");
      const setInput2 = document.getElementById("setInput2");
      const calculateSetOperationsButton = document.getElementById("calculateSetOperationsButton");
      const setOperationsResult = document.getElementById("setOperationsResult");

      const stackItemInput = document.getElementById("stackItemInput");
      const pushButton = document.getElementById("pushButton");
      const popButton = document.getElementById("popButton");
      const peekStackButton = document.getElementById("peekStackButton");
      const stackContainer = document.getElementById("stackContainer");
      const stackResultDisplay = document.getElementById("stackResultDisplay");
      const stackMessage = document.getElementById("stackMessage");

      const queueItemInput = document.getElementById("queueItemInput");
      const enqueueButton = document.getElementById("enqueueButton");
      const dequeueButton = document.getElementById("dequeueButton");
      const peekQueueButton = document.getElementById("peekQueueButton");
      const queueContainer = document.getElementById("queueContainer");
      const queueResultDisplay = document.getElementById("queueResultDisplay");
      const queueMessage = document.getElementById("queueMessage");

      const checkQuizButtonDS = document.getElementById("checkQuizButtonDS");
      const quizResultDS = document.getElementById("quizResultDS");

      // --- State ---
      let interactiveSet = new Set(["apple", "banana", "cherry"]);
      let interactiveStack = ["A", "B"]; // Simulate stack with array (top is end)
      let interactiveQueue = ["P1", "P2"]; // Simulate queue with array (front is start)

      // --- Set Logic ---
      function renderSet() {
        setContainer.innerHTML = ""; // Clear previous
        if (interactiveSet.size === 0) {
          setContainer.innerHTML =
            '<span class="text-gray-500 italic">Set is empty</span>';
          return;
        }
        interactiveSet.forEach((item) => {
          const span = document.createElement("span");
          span.className = "ds-item set-item";
          span.textContent = item;
          setContainer.appendChild(span);
        });
      }

      calculateSetOperationsButton.addEventListener("click", () => {
        const set1 = new Set(setInput1.value.split(",").map(Number));
        const set2 = new Set(setInput2.value.split(",").map(Number));

        const union = new Set([...set1, ...set2]);
        const intersection = new Set([...set1].filter(x => set2.has(x)));
        const difference = new Set([...set1].filter(x => !set2.has(x)));
        const symmetricDifference = new Set([...set1, ...set2].filter(x => !intersection.has(x)));

        setOperationsResult.textContent = `
          Union: ${Array.from(union).join(", ")}
          Intersection: ${Array.from(intersection).join(", ")}
          Difference (set1 - set2): ${Array.from(difference).join(", ")}
          Symmetric Difference: ${Array.from(symmetricDifference).join(", ")}
        `;
      });

      // --- Stack Logic ---
      function renderStack() {
        stackContainer.innerHTML = ""; // Clear previous
        if (interactiveStack.length === 0) {
          stackContainer.innerHTML =
            '<span class="text-gray-500 italic">Stack is empty</span>';
          return;
        }
        // Render bottom-up visually
        interactiveStack.forEach((item, index) => {
          const span = document.createElement("span");
          span.className = "ds-item stack-item";
          span.textContent = item;
          if (index === interactiveStack.length - 1) {
            span.classList.add("top"); // Mark the top item
          }
          stackContainer.appendChild(span);
        });
      }

      pushButton.addEventListener("click", () => {
        const item = stackItemInput.value.trim();
        if (!item) {
          showMessage(stackMessage, "Please enter an item to push.", "error");
          return;
        }
        interactiveStack.push(item);
        renderStack();
        stackResultDisplay.textContent = `Pushed "${item}" onto the stack.`;
        stackItemInput.value = "";
        showMessage(stackMessage, "Item pushed.", "success");
      });

      popButton.addEventListener("click", () => {
        if (interactiveStack.length === 0) {
          stackResultDisplay.textContent = "Stack is empty. Cannot pop.";
          showMessage(stackMessage, "Stack is empty.", "error");
          return;
        }
        const poppedItem = interactiveStack.pop();
        renderStack();
        stackResultDisplay.textContent = `Popped "${poppedItem}" from the stack.`;
        showMessage(stackMessage, "Item popped.", "success");
      });

      peekStackButton.addEventListener("click", () => {
        renderStack(); // Ensure top is marked
        if (interactiveStack.length === 0) {
          stackResultDisplay.textContent = "Stack is empty.";
          showMessage(stackMessage, "Stack is empty.", "info");
        } else {
          const topItem = interactiveStack[interactiveStack.length - 1];
          stackResultDisplay.textContent = `Top item is "${topItem}".`;
          showMessage(stackMessage, "Peeked at top item.", "info");
        }
      });

      // --- Queue Logic ---
      function renderQueue() {
        queueContainer.innerHTML = ""; // Clear previous
        if (interactiveQueue.length === 0) {
          queueContainer.innerHTML =
            '<span class="text-gray-500 italic">Queue is empty</span>';
          return;
        }
        interactiveQueue.forEach((item, index) => {
          const span = document.createElement("span");
          span.className = "ds-item queue-item";
          span.textContent = item;
          if (index === 0) {
            span.classList.add("front"); // Mark the front item
          }
          if (index === interactiveQueue.length - 1) {
            span.classList.add("rear"); // Mark the rear item
          }
          queueContainer.appendChild(span);
        });
      }

      enqueueButton.addEventListener("click", () => {
        const item = queueItemInput.value.trim();
        if (!item) {
          showMessage(
            queueMessage,
            "Please enter an item to enqueue.",
            "error"
          );
          return;
        }
        interactiveQueue.push(item); // Add to the end (rear)
        renderQueue();
        queueResultDisplay.textContent = `Enqueued "${item}" to the rear.`;
        queueItemInput.value = "";
        showMessage(queueMessage, "Item enqueued.", "success");
      });

      dequeueButton.addEventListener("click", () => {
        if (interactiveQueue.length === 0) {
          queueResultDisplay.textContent = "Queue is empty. Cannot dequeue.";
          showMessage(queueMessage, "Queue is empty.", "error");
          return;
        }
        const dequeuedItem = interactiveQueue.shift(); // Remove from the front
        renderQueue();
        queueResultDisplay.textContent = `Dequeued "${dequeuedItem}" from the front.`;
        showMessage(queueMessage, "Item dequeued.", "success");
      });

      peekQueueButton.addEventListener("click", () => {
        renderQueue(); // Ensure front is marked
        if (interactiveQueue.length === 0) {
          queueResultDisplay.textContent = "Queue is empty.";
          showMessage(queueMessage, "Queue is empty.", "info");
        } else {
          const frontItem = interactiveQueue[0];
          queueResultDisplay.textContent = `Front item is "${frontItem}".`;
          showMessage(queueMessage, "Peeked at front item.", "info");
        }
      });

      // --- Quiz Logic ---
      function checkDSQuiz() {
        const answers = {
          q1_ds: "b", // Set
          q2_ds: "c", // LIFO (Stack)
          q3_ds: "b", // Enqueue
          q4_ds: "c", // collections.deque
        };
        let score = 0;
        let resultsHTML = "<ul>";
        let allAnswered = true;

        for (const q in answers) {
          const selected = document.querySelector(`input[name="${q}"]:checked`);
          if (!selected) {
            allAnswered = false;
            break;
          }
          const isCorrect = selected.value === answers[q];
          if (isCorrect) {
            score++;
            resultsHTML += `<li class="text-green-700">✓ Question ${q.substring(
              1,
              2
            )}: Correct!</li>`;
          } else {
            resultsHTML += `<li class="text-red-700">✗ Question ${q.substring(
              1,
              2
            )}: Incorrect.</li>`;
          }
        }

        if (!allAnswered) {
          quizResultDS.textContent =
            "Please answer all questions before checking.";
          quizResultDS.className = "message-box message-box-error";
          quizResultDS.style.display = "block";
          return;
        }

        resultsHTML += "</ul>";
        resultsHTML =
          `<p class="font-medium mb-2">You scored ${score} out of ${
            Object.keys(answers).length
          }.</p>` + resultsHTML;

        quizResultDS.innerHTML = resultsHTML;
        quizResultDS.className =
          score === Object.keys(answers).length
            ? "message-box message-box-success"
            : "message-box message-box-error";
        quizResultDS.style.display = "block";
      }

      // --- Event Listeners ---
      checkQuizButtonDS.addEventListener("click", checkDSQuiz);

      // --- Initial Setup ---
      // renderSet(); // No longer have setContainer, this was for a different set example
      renderStack();
      renderQueue();
    </script>
  </body>
</html>
