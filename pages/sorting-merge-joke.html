<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Learn Merge Sort & Joke Sorts</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/shared-styles.css">
  </head>
  <body class="bg-blue-700 text-gray-300 min-h-screen p-4 md:p-8">
    <header class="text-center mb-8">
      <a href="../index.html" class="text-3xl md:text-4xl font-bold text-yellow-300 hover:text-yellow-200 transition-colors duration-200">
        Interactive Guide to Python
      </a>
      <h1 class="text-2xl md:text-3xl font-semibold text-yellow-400 mt-2">
        Understanding Merge Sort & "Joke" Sorts
      </h1>
      <p class="text-xs text-cyan-500 mt-1 italic">
        Understanding the efficient Merge Sort algorithm and exploring some humorous, impractical sorting methods.
      </p>
    </header>

    <nav
      class="max-w-4xl mx-auto mb-6 p-3 bg-blue-800 rounded-lg shadow-md flex justify-between items-center">
      <a href="sorting-basic.html"
        class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition-colors duration-200">
        &larr; Previous: Sorting Algorithms (Bubble/Selection)
      </a>
      <a href="searching-binary.html"
        class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition-colors duration-200">
        Next: Searching (Binary Search) &rarr;
      </a>
    </nav>

    <main class="max-w-4xl mx-auto">
      <section class="mb-8 interactive-section">
        <h2 class="text-2xl font-semibold text-yellow-300 mb-3">
          1. Merge Sort: Divide and Conquer
        </h2>
        <p class="mb-2 text-gray-300">
          Merge Sort is an efficient, comparison-based sorting algorithm that
          uses a **Divide and Conquer** strategy. It's known for its reliable
          performance.
        </p>
        <p class="mb-2"><strong>How it works:</strong></p>
        <ol class="list-decimal list-inside ml-4 space-y-1 text-sm">
          <li>
            <strong>Divide:</strong> If the list has more than one element,
            divide it recursively into two roughly equal halves.
          </li>
          <li>
            <strong>Conquer:</strong> Recursively sort each half using Merge
            Sort (this continues until you have lists of size 1, which are
            inherently sorted).
          </li>
          <li>
            <strong>Combine (Merge):</strong> Merge the two sorted halves back
            into a single sorted list. This merge step involves comparing
            elements from the start of both sorted halves and placing the
            smaller one into the result list, repeating until one half is
            exhausted, then appending the rest of the other half.
          </li>
        </ol>
        <p class="mt-2 text-sm text-gray-300">
          Merge Sort has a time complexity of O(n log n) in all cases (worst,
          average, best), making it very efficient for large datasets. Its main
          drawback is that it requires additional space (O(n)) to store the
          merged subarrays during the combine step.
        </p>

        <h3 class="text-lg font-medium mt-4 mb-2">Visualize Merge Sort:</h3>
        <div class="flex flex-wrap items-center mb-2">
          <button id="runMergeSortButton" class="btn btn-green">
            Run Merge Sort
          </button>
          <button id="resetMergeSortButton" class="btn btn-orange">
            Reset
          </button>
          <label for="mergeSpeedRange" class="ml-4 mr-1 text-sm">Speed:</label>
          <input
            type="range"
            id="mergeSpeedRange"
            min="100"
            max="1500"
            value="500"
            step="100"
            class="align-middle"
          />
        </div>
        <div id="mergeSortContainer" class="sort-container"></div>
        <h4 class="text-md font-medium mt-3 mb-1">Log:</h4>
        <div id="mergeSortLog" class="output-display">
          <span class="text-gray-500 italic"
            >Click 'Run Merge Sort' to start visualization.</span
          >
        </div>
        <div
          id="mergeSortMessage"
          class="message-box"
          style="display: none"
        ></div>
      </section>

      <section class="mb-8">
        <h2 class="text-2xl font-semibold text-yellow-300 mb-3">
          2. Joke Sorting Algorithms
        </h2>
        <p class="mb-4 text-gray-300">
          While algorithms like Merge Sort are practical and efficient, computer
          science also has some notoriously inefficient or purely theoretical
          "joke" algorithms. These are primarily used for educational purposes
          (to illustrate bad approaches) or humor.
        </p>
      </section>

      <section class="mb-8 interactive-section">
        <h2 class="text-2xl font-semibold text-yellow-300 mb-3">
          2a. Bogo Sort
        </h2>
        <p class="mb-2 text-gray-300">
          Bogo Sort is famous for its extreme inefficiency. It's based purely on
          chance.
        </p>
        <p class="mb-2"><strong>How it works:</strong></p>
        <ol class="list-decimal list-inside ml-4 space-y-1 text-sm">
          <li>Check if the list is already sorted. If yes, stop.</li>
          <li>If not sorted, randomly shuffle the elements of the list.</li>
          <li>Go back to step 1.</li>
        </ol>
        <p class="mt-2 text-sm text-red-600 font-medium">
          <strong>Warning:</strong> Bogo Sort has an average time complexity
          that is astronomically bad (related to O(n * n!)). It might never
          finish sorting even moderately sized lists within a reasonable
          timeframe (or even the lifetime of the universe!). It serves as an
          example of a terrible algorithm.
        </p>

        <h3 class="text-lg font-medium mt-4 mb-2">Visualize Bogo Sort:</h3>
        <p class="text-xs text-gray-500">
          Using a very small list (5 elements) for demonstration.
        </p>
        <div class="flex flex-wrap items-center mb-2">
          <button id="runBogoSortButton" class="btn btn-red">
            Run Bogo Sort (Max 1000 attempts)
          </button>
          <button id="resetBogoSortButton" class="btn btn-orange">Reset</button>
        </div>
        <div id="bogoSortContainer" class="sort-container"></div>
        <div id="bogoStatus" class="bogo-status not-sorted">
          Status: Not Sorted
        </div>
        <h4 class="text-md font-medium mt-3 mb-1">Log:</h4>
        <div id="bogoSortLog" class="output-display">
          <span class="text-gray-500 italic"
            >Click 'Run Bogo Sort'. Be patient (or lucky!).</span
          >
        </div>
        <div
          id="bogoSortMessage"
          class="message-box"
          style="display: none"
        ></div>
      </section>

      <section class="mb-8 interactive-section">
        <h2 class="text-2xl font-semibold text-yellow-300 mb-3">
          2b. Quantum Tunneling Sort (Theoretical Joke)
        </h2>
        <p class="mb-2 text-gray-300">
          This is a purely theoretical joke algorithm based on a
          misunderstanding or humorous application of quantum mechanics.
        </p>
        <p class="mb-2"><strong>How it "works" (conceptually):</strong></p>
        <ol class="list-decimal list-inside ml-4 space-y-1 text-sm">
          <li>Check if the list is sorted.</li>
          <li>
            If not, wait. According to some interpretations of quantum
            mechanics, there is a non-zero (but unimaginably tiny) probability
            that the particles making up the computer's memory will
            spontaneously rearrange ("quantum tunnel") themselves into a sorted
            order.
          </li>
          <li>Go back to step 1.</li>
        </ol>
        <p class="mt-2 text-sm text-red-600 font-medium">
          This is **not** a practical algorithm. The probability of it working
          is effectively zero for any list of more than a couple of elements
          within the age of the universe. It highlights the difference between
          theoretical possibility and practical computability. There's no
          visualization for this, as it relies on waiting for an event that
          essentially never happens.
        </p>
      </section>

      <section class="mb-8 interactive-section">
        <h2 class="text-2xl font-semibold text-yellow-300 mb-3">3. Quick Quiz</h2>
        <p class="mb-4 text-gray-300">Test your understanding!</p>
        <div class="mb-3">
          <p class="font-medium mb-1 text-gray-200">
            Q1: What is the primary strategy used by Merge Sort?
          </p>
          <label class="block text-gray-300"
            ><input type="radio" name="q1_merge" value="a" class="mr-1" /> Iterative
            swapping</label
          >
          <label class="block text-gray-300"
            ><input type="radio" name="q1_merge" value="b" class="mr-1" /> Divide
            and Conquer</label
          >
          <label class="block text-gray-300"
            ><input type="radio" name="q1_merge" value="c" class="mr-1" /> Random
            shuffling</label
          >
        </div>
        <div class="mb-3">
          <p class="font-medium mb-1 text-gray-200">
            Q2: What is the typical time complexity of Merge Sort?
          </p>
          <label class="block text-gray-300"
            ><input type="radio" name="q2_merge" value="a" class="mr-1" /> O(n<sup>2</sup>)</label
          >
          <label class="block text-gray-300"
            ><input type="radio" name="q2_merge" value="b" class="mr-1" /> O(n log n)</label
          >
          <label class="block text-gray-300"
            ><input type="radio" name="q2_merge" value="c" class="mr-1" /> O(n!)</label
          >
        </div>
        <div class="mb-3">
          <p class="font-medium mb-1 text-gray-200">
            Q3: What is a notable characteristic of Bogo Sort?
          </p>
          <label class="block text-gray-300"
            ><input type="radio" name="q3_merge" value="a" class="mr-1" /> It's
            very memory efficient.</label
          >
          <label class="block text-gray-300"
            ><input type="radio" name="q3_merge" value="b" class="mr-1" /> It has
            no worst-case scenario.</label
          >
          <label class="block text-gray-300"
            ><input type="radio" name="q3_merge" value="c" class="mr-1" /> It's
            extremely inefficient and relies on chance.</label
          >
        </div>
        <button id="checkQuizButtonMerge" class="btn">Check Answers</button>
        <div
          id="quizResultMerge"
          class="message-box mt-4"
          style="display: none"
        ></div>
      </section>
    </main>

    <footer class="text-center mt-12 py-6 border-t border-yellow-500">
      <p class="text-sm text-cyan-300">
        &copy; 2024 Interactive Guide to Python. Happy Coding!
      </p>
    </footer>

    <script src="../js/main.js" defer></script>
    <script>
      // --- DOM Elements & Shared State ---
      const mergeSortContainer = document.getElementById("mergeSortContainer");
      const runMergeSortButton = document.getElementById("runMergeSortButton");
      const resetMergeSortButton = document.getElementById(
        "resetMergeSortButton"
      );
      const mergeSortLog = document.getElementById("mergeSortLog");
      const mergeSortMessage = document.getElementById("mergeSortMessage");
      const mergeSpeedRange = document.getElementById("mergeSpeedRange");

      const bogoSortContainer = document.getElementById("bogoSortContainer");
      const runBogoSortButton = document.getElementById("runBogoSortButton");
      const resetBogoSortButton = document.getElementById(
        "resetBogoSortButton"
      );
      const bogoSortLog = document.getElementById("bogoSortLog");
      const bogoSortMessage = document.getElementById("bogoSortMessage");
      const bogoStatus = document.getElementById("bogoStatus");

      const checkQuizButtonMerge = document.getElementById(
        "checkQuizButtonMerge"
      );
      const quizResultMerge = document.getElementById("quizResultMerge");

      const initialArrayMerge = [65, 55, 45, 35, 25, 15, 70, 50]; // Sample data for merge
      const initialArrayBogo = [40, 20, 50, 10, 30]; // Smaller array for Bogo
      let mergeArray = [...initialArrayMerge];
      let bogoArray = [...initialArrayBogo];
      let mergeSortTimeout = null;
      let bogoSortTimeout = null;
      let bogoAttempts = 0;
      const MAX_BOGO_ATTEMPTS = 1000; // Safety limit
      const MAX_VAL = 100; // For scaling bar height

      // --- Visualization Functions (Reused & Adapted) ---
      function renderBars(
        container,
        array,
        highlightIndices = [],
        highlightClass = "comparing"
      ) {
        container.innerHTML = ""; // Clear previous bars
        const maxValue = Math.max(...array, MAX_VAL);
        array.forEach((value, index) => {
          const bar = document.createElement("div");
          bar.className = "sort-bar";
          const heightPercent = Math.max(5, (value / maxValue) * 100);
          bar.style.height = `${heightPercent}%`;
          bar.textContent = value;
          bar.dataset.value = value;
          bar.dataset.index = index; // Keep original index if needed? No, current index is fine.
          if (highlightIndices.includes(index)) {
            bar.classList.add(highlightClass);
          }
          container.appendChild(bar);
        });
      }

      function updateMergeVisual(container, array, message, logElement) {
        renderBars(container, array); // Re-render based on current array state
        logElement.innerHTML += message + "\n";
        logElement.scrollTop = logElement.scrollHeight;
      }

      function markAllSorted(container) {
        container.querySelectorAll(".sort-bar").forEach((bar) => {
          bar.classList.add("sorted");
        });
      }

      // --- Sorting Algorithm Logic (Async Generators/Functions) ---

      // Merge Sort Visualization Logic
      async function mergeSortVisual(
        array,
        container,
        logElement,
        speedFunc,
        level = 0
      ) {
        const n = array.length;
        const indent = "&nbsp;".repeat(level * 2);
        logElement.innerHTML += `${indent}MergeSort called on: [${array.join(
          ", "
        )}]\n`;
        logElement.scrollTop = logElement.scrollHeight;
        await new Promise((resolve) => setTimeout(resolve, speedFunc()));

        if (n <= 1) {
          logElement.innerHTML += `${indent}Base case: Array size <= 1. Returning [${array.join(
            ", "
          )}].\n`;
          logElement.scrollTop = logElement.scrollHeight;
          // Render single element bar as 'sorted' conceptually
          renderBars(container, array);
          markAllSorted(container);
          await new Promise((resolve) => setTimeout(resolve, speedFunc()));
          return array;
        }

        const mid = Math.floor(n / 2);
        const leftHalf = array.slice(0, mid);
        const rightHalf = array.slice(mid);

        // Create temporary containers for visualization (optional, can be complex)
        // For simplicity, we'll just log the division

        logElement.innerHTML += `${indent}Dividing into: [${leftHalf.join(
          ", "
        )}] and [${rightHalf.join(", ")}]\n`;
        logElement.scrollTop = logElement.scrollHeight;
        renderBars(container, array); // Show original before recursive calls visually change it
        await new Promise((resolve) => setTimeout(resolve, speedFunc()));

        // Recursively sort halves
        const sortedLeft = await mergeSortVisual(
          leftHalf,
          container,
          logElement,
          speedFunc,
          level + 1
        );
        const sortedRight = await mergeSortVisual(
          rightHalf,
          container,
          logElement,
          speedFunc,
          level + 1
        );

        // Merge the sorted halves
        logElement.innerHTML += `${indent}Merging: [${sortedLeft.join(
          ", "
        )}] and [${sortedRight.join(", ")}]\n`;
        logElement.scrollTop = logElement.scrollHeight;
        // Show the two sorted halves side-by-side conceptually before merge
        renderBars(container, [...sortedLeft, ...sortedRight]); // Render combined but not yet merged
        container.querySelectorAll(".sort-bar").forEach((bar, i) => {
          if (i < sortedLeft.length)
            bar.classList.add("merging"); // Highlight left being considered
          else bar.classList.add("comparing"); // Highlight right being considered
        });
        await new Promise((resolve) => setTimeout(resolve, speedFunc()));

        const mergedArray = [];
        let i = 0,
          j = 0;
        while (i < sortedLeft.length && j < sortedRight.length) {
          // Log comparison
          logElement.innerHTML += `${indent}  Comparing ${sortedLeft[i]} and ${sortedRight[j]}... `;

          if (sortedLeft[i] <= sortedRight[j]) {
            mergedArray.push(sortedLeft[i]);
            logElement.innerHTML += `Taking ${sortedLeft[i]}\n`;
            i++;
          } else {
            mergedArray.push(sortedRight[j]);
            logElement.innerHTML += `Taking ${sortedRight[j]}\n`;
            j++;
          }
          logElement.scrollTop = logElement.scrollHeight;
          // Update visualization incrementally during merge
          renderBars(container, [
            ...mergedArray,
            ...sortedLeft.slice(i),
            ...sortedRight.slice(j),
          ]);
          markAllSorted(container); // Mark merged part as sorted
          await new Promise((resolve) => setTimeout(resolve, speedFunc() / 2)); // Faster merge steps
        }

        // Append remaining elements
        while (i < sortedLeft.length) {
          mergedArray.push(sortedLeft[i]);
          i++;
        }
        while (j < sortedRight.length) {
          mergedArray.push(sortedRight[j]);
          j++;
        }

        logElement.innerHTML += `${indent}Merged result: [${mergedArray.join(
          ", "
        )}]\n`;
        logElement.scrollTop = logElement.scrollHeight;
        renderBars(container, mergedArray); // Show final merged state for this level
        markAllSorted(container);
        await new Promise((resolve) => setTimeout(resolve, speedFunc()));

        return mergedArray;
      }

      // Bogo Sort Logic
      // Fisher-Yates (Knuth) Shuffle Algorithm
      function shuffleArray(array) {
        let currentIndex = array.length,
          randomIndex;
        while (currentIndex !== 0) {
          randomIndex = Math.floor(Math.random() * currentIndex);
          currentIndex--;
          [array[currentIndex], array[randomIndex]] = [
            array[randomIndex],
            array[currentIndex],
          ];
        }
        return array;
      }

      function isSorted(array) {
        for (let i = 0; i < array.length - 1; i++) {
          if (array[i] > array[i + 1]) {
            return false;
          }
        }
        return true;
      }

      async function runBogoSortVisual() {
        runBogoSortButton.disabled = true;
        resetBogoSortButton.disabled = true; // Disable reset during run
        bogoSortLog.innerHTML = "Starting Bogo Sort...\n";
        bogoAttempts = 0;
        let sorted = false;

        while (bogoAttempts < MAX_BOGO_ATTEMPTS && !sorted) {
          bogoAttempts++;
          bogoSortLog.innerHTML += `Attempt ${bogoAttempts}: Shuffling...\n`;
          bogoSortLog.scrollTop = bogoSortLog.scrollHeight;

          bogoArray = shuffleArray([...bogoArray]);
          renderBars(bogoSortContainer, bogoArray); // Show shuffled state
          bogoSortContainer
            .querySelectorAll(".sort-bar")
            .forEach((bar) => bar.classList.add("shuffled"));
          await new Promise((resolve) => setTimeout(resolve, 100)); // Short delay for shuffle vis

          sorted = isSorted(bogoArray);
          bogoSortLog.innerHTML += `Checking if sorted: ${
            sorted ? "YES!" : "No."
          }\n`;
          bogoSortLog.scrollTop = bogoSortLog.scrollHeight;

          bogoStatus.textContent = `Status: ${
            sorted ? "Sorted!" : "Not Sorted"
          }`;
          bogoStatus.className = `bogo-status ${
            sorted ? "sorted" : "not-sorted"
          }`;

          if (sorted) {
            renderBars(bogoSortContainer, bogoArray); // Final render
            markAllSorted(bogoSortContainer);
            bogoSortLog.innerHTML += `\nBogo Sort SUCCESSFUL after ${bogoAttempts} attempts!\n`;
            showMessage(
              bogoSortMessage,
              `Sorted after ${bogoAttempts} attempts!`,
              "success"
            );
            break;
          }

          // Clear shuffle highlight before next attempt (if not sorted)
          await new Promise((resolve) => setTimeout(resolve, 150));
          bogoSortContainer
            .querySelectorAll(".sort-bar")
            .forEach((bar) => bar.classList.remove("shuffled"));
        }

        if (!sorted) {
          bogoSortLog.innerHTML += `\nBogo Sort FAILED after ${MAX_BOGO_ATTEMPTS} attempts.\n`;
          showMessage(
            bogoSortMessage,
            `Failed to sort within ${MAX_BOGO_ATTEMPTS} attempts.`,
            "error"
          );
        }

        runBogoSortButton.disabled = false;
        resetBogoSortButton.disabled = false;
      }

      // --- Event Listeners & Control ---
      runMergeSortButton.addEventListener("click", async () => {
        runMergeSortButton.disabled = true;
        resetMergeSortButton.disabled = true;
        mergeSortLog.innerHTML = ""; // Clear log
        mergeSortMessage.style.display = "none";
        const speed = () => 1600 - parseInt(mergeSpeedRange.value, 10); // Speed control

        try {
          // Make a copy to sort visually
          let arrayToSort = [...mergeArray];
          const sortedResult = await mergeSortVisual(
            arrayToSort,
            mergeSortContainer,
            mergeSortLog,
            speed
          );
          // Update the original array state if needed, or just confirm completion
          // mergeArray = sortedResult; // If we want the state to persist
          mergeSortLog.innerHTML += "\nMerge Sort Complete!\n";
          showMessage(mergeSortMessage, "Merge Sort complete!", "success");
        } catch (e) {
          console.error("Merge Sort error:", e);
          showMessage(
            mergeSortMessage,
            "An error occurred during sorting.",
            "error"
          );
        } finally {
          runMergeSortButton.disabled = false;
          resetMergeSortButton.disabled = false;
        }
      });

      resetMergeSortButton.addEventListener("click", () => {
        // Need a way to stop the async generator if running - complex.
        // For now, just reset the visual state.
        mergeArray = [...initialArrayMerge];
        renderBars(mergeSortContainer, mergeArray);
        mergeSortLog.innerHTML =
          "<span class=\"text-gray-500 italic\">Reset. Click 'Run Merge Sort' to start visualization.</span>";
        runMergeSortButton.disabled = false;
        showMessage(
          mergeSortMessage,
          "Merge Sort visualization reset.",
          "info"
        );
      });

      runBogoSortButton.addEventListener("click", runBogoSortVisual);

      resetBogoSortButton.addEventListener("click", () => {
        // Need a way to stop the bogo sort loop if running - complex.
        // For now, just reset the visual state.
        bogoArray = [...initialArrayBogo];
        renderBars(bogoSortContainer, bogoArray);
        bogoSortLog.innerHTML =
          "<span class=\"text-gray-500 italic\">Reset. Click 'Run Bogo Sort'.</span>";
        bogoStatus.textContent = "Status: Not Sorted";
        bogoStatus.className = "bogo-status not-sorted";
        runBogoSortButton.disabled = false;
        showMessage(bogoSortMessage, "Bogo Sort visualization reset.", "info");
      });

      // --- Quiz Logic ---
      function checkMergeQuiz() {
        const answers = {
          q1_merge: "b", // Divide and Conquer
          q2_merge: "b", // O(n log n)
          q3_merge: "c", // Randomly shuffling
        };
        let score = 0;
        let resultsHTML = "<ul>";
        let allAnswered = true;

        for (const q in answers) {
          const selected = document.querySelector(`input[name="${q}"]:checked`);
          if (!selected) {
            allAnswered = false;
            break;
          }
          const isCorrect = selected.value === answers[q];
          if (isCorrect) {
            score++;
            resultsHTML += `<li class="text-green-700">✓ Question ${q.substring(
              1,
              2
            )}: Correct!</li>`;
          } else {
            resultsHTML += `<li class="text-red-700">✗ Question ${q.substring(
              1,
              2
            )}: Incorrect.</li>`;
          }
        }

        if (!allAnswered) {
          quizResultMerge.textContent =
            "Please answer all questions before checking.";
          quizResultMerge.className = "message-box message-box-error";
          quizResultMerge.style.display = "block";
          return;
        }

        resultsHTML += "</ul>";
        resultsHTML =
          `<p class="font-medium mb-2">You scored ${score} out of ${
            Object.keys(answers).length
          }.</p>` + resultsHTML;

        quizResultMerge.innerHTML = resultsHTML;
        quizResultMerge.className =
          score === Object.keys(answers).length
            ? "message-box message-box-success"
            : "message-box message-box-error";
        quizResultMerge.style.display = "block";
      }

      // --- Event Listeners ---
      checkQuizButtonMerge.addEventListener("click", checkMergeQuiz);

      // --- Initial Setup ---
      window.onload = () => {
        renderBars(mergeSortContainer, mergeArray);
        renderBars(bogoSortContainer, bogoArray);
      };
    </script>
  </body>
</html>
