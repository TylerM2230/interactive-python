<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dictionaries & Tuples - Python Guide</title>
    <!-- <script src="https://cdn.tailwindcss.com"></script> -->
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/shared-styles.css">
  </head>
  <body class="min-h-screen">
    <div class="console-screen-border">
      <header class="text-center mb-12 md:mb-16">
        <h1 class="pixel-header">
          Interactive Python Guide
        </h1>
        <p class="pixel-subheader mt-4">
          Retro Journey into Code!
        </p>
      </header>

      <main class="mx-auto">
        <h1 class="page-title-8bit">
          Dictionaries & Tuples
        </h1>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            1. Dictionaries (<code>dict</code>): Key-Value Stores
          </h2>
          <div class="sub-interactive-box">
            <p>
              A dictionary in Python is an unordered (prior to Python 3.7) or ordered (Python 3.7+) collection of <strong>key-value pairs</strong>. Each key is unique and is used to store and retrieve its associated value. Think of it like a real-world dictionary where a word (the key) maps to its definition (the value), or a phone book where a name (key) maps to a phone number (value).
            </p>
            <p>Key characteristics of dictionaries:</p>
            <ul>
              <li>
                <strong>Key-Value Pairs:</strong> Data is stored in <code>key: value</code> format. Keys are used to access their corresponding values efficiently.
              </li>
              <li>
                <strong>Mutable:</strong> Dictionaries can be changed after they are created. You can add, remove, or update key-value pairs.
              </li>
              <li>
                <strong>Ordered (Python 3.7+):</strong> Since Python 3.7 (and CPython 3.6), dictionaries remember the order in which items were inserted. In older Python versions, they were unordered.
              </li>
              <li>
                <strong>Unique Keys:</strong> Keys within a single dictionary must be unique. If you assign a value to an existing key, it will overwrite the previous value. Values, however, can be duplicated.
              </li>
              <li>
                <strong>Keys Must Be Immutable:</strong> Keys must be of an immutable type (e.g., strings, numbers, tuples containing only immutable elements). Lists or other dictionaries cannot be used as keys because they are mutable.
              </li>
            </ul>
            <h3 class="section-subtitle-8bit smaller-subtitle">Creating Dictionaries:</h3>
            <pre><code class="code-block-8bit python"># Creating an empty dictionary
empty_dict_v1 = {}
empty_dict_v2 = dict()

# Creating a dictionary with initial items
player_stats = {
  "name": "Pixel Knight",
  "level": 5,
  "hp": 100,
  "inventory": ["sword", "shield", "potion"], # Values can be any type
  "active_quest": None
}

print(f"Player Stats: {player_stats}")
print(f"Type of player_stats: {type(player_stats)}") # Output: <class 'dict'></code></pre>
            <h3 class="section-subtitle-8bit smaller-subtitle">Accessing Values:</h3>
            <p>
              You access values using their corresponding key inside square brackets <code>[]</code>. If the key doesn't exist, this will raise a <code>KeyError</code>. A safer way to access values is using the <code>.get()</code> method, which can return a default value if the key is not found.
            </p>
            <pre><code class="code-block-8bit python"># Accessing with [] (raises KeyError if key is missing)
print(f"Player Name: {player_stats["name"]}")  # Output: Pixel Knight
# print(player_stats["experience"]) # This would cause a KeyError

# Safer access using .get(key, default_value)
experience = player_stats.get("experience", 0) # Returns 0 if "experience" key doesn't exist
print(f"Player Experience: {experience}")      # Output: Player Experience: 0

current_hp = player_stats.get("hp")
print(f"Player HP: {current_hp}")             # Output: Player HP: 100</code></pre>
            <h3 class="section-subtitle-8bit smaller-subtitle">Adding or Updating Items:</h3>
            <p>You can add a new key-value pair or update the value of an existing key using assignment.</p>
            <pre><code class="code-block-8bit python"># Add a new key-value pair
player_stats["experience"] = 1500
print(f"Updated Experience: {player_stats["experience"]}")

# Update an existing value
player_stats["hp"] = 95 # Player took some damage!
player_stats["inventory"] = ["sword", "shield"] # Lost a potion
print(f"Updated HP: {player_stats["hp"]}")
print(f"Updated Inventory: {player_stats["inventory"]}")

print(f"\nFull Player Stats after updates:\n{player_stats}")</code></pre>
            <h3 class="section-subtitle-8bit smaller-subtitle">Removing Items:</h3>
            <pre><code class="code-block-8bit python"># Using del statement (raises KeyError if key is missing)
if "active_quest" in player_stats:
    del player_stats["active_quest"]
print(f"Quest removed (del): {player_stats.get('active_quest', 'No active quest')}")

# Using .pop(key, default_value) (returns value, safer)
removed_level = player_stats.pop("level", -1) # Returns -1 if not found
print(f"Removed level: {removed_level}")
print(f"Level after pop: {player_stats.get('level', 'Level key not found')}")

# Using .popitem() (removes and returns the last inserted (key,value) pair in LIFO order since Py 3.7)
# Useful for destructively iterating through a dictionary.
if player_stats: # Check if dictionary is not empty
    last_item = player_stats.popitem()
    print(f"Popped item: {last_item}")
    print(f"Dictionary after popitem: {player_stats}")</code></pre>
            <h3 class="section-subtitle-8bit smaller-subtitle">Iterating Through Dictionaries:</h3>
            <pre><code class="code-block-8bit python">player_config = {"difficulty": "hard", "sound": True, "autosave": False}

# Iterate through keys (this is the default iteration behavior)
print("\nIterating through Keys:")
for k in player_config:
  print(f"  Key: {k}, Value: {player_config[k]}")

# Iterate through values using .values()
print("\nIterating through Values:")
for v in player_config.values():
  print(f"  Value: {v}")

# Iterate through key-value pairs using .items()
print("\nIterating through Items (key-value pairs):")
for key, value_item in player_config.items():
  print(f"  {key} -> {value_item}")</code></pre>
            <h3 class="section-subtitle-8bit smaller-subtitle">Other Useful Dictionary Methods:</h3>
             <ul>
                <li><code>len(my_dict)</code>: Returns the number of key-value pairs.</li>
                <li><code>key in my_dict</code>: Returns <code>True</code> if <code>key</code> exists in the dictionary, <code>False</code> otherwise.</li>
                <li><code>my_dict.clear()</code>: Removes all items from the dictionary.</li>
                <li><code>my_dict.copy()</code>: Returns a shallow copy of the dictionary.</li>
                <li><code>dict.fromkeys(sequence, value)</code>: Creates a new dictionary with keys from sequence and all values set to <code>value</code>.</li>
            </ul>
          </div>
        </section>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            Interactive Dictionary Operations (Display Only)
          </h2>
          <div class="sub-interactive-box">
            <p>This area is for displaying dictionary states. (No interactive JS implemented yet for this section, but styled for future use).</p>
            <div class="grid-cols-2-responsive mt-4">
              <div>
                <h3 class="section-subtitle-8bit smaller-subtitle">Current Dictionary State:</h3>
                <div id="dictDisplay" class="output-display-8bit min-h-[150px]"><p>{ "name": "Hero", "class": "Warrior", "level": 10 }</p></div>
              </div>
              <div>
                <h3 class="section-subtitle-8bit smaller-subtitle">Operation Result / Log:</h3>
                <div id="dictResultDisplay" class="output-display-8bit min-h-[150px]"><p><em>No operation performed yet.</em></p></div>
              </div>
            </div>
            <div id="dictMessage" class="message-box-8bit mt-2" style="display: none;">Message area</div>
          </div>
        </section>

        <section class="interactive-section">
          <h2 class="section-subtitle-8bit">
            2. Tuples (<code>tuple</code>): Immutable Sequences
          </h2>
          <div class="sub-interactive-box">
            <p>
              A tuple is an <strong>ordered, immutable sequence</strong> of items. \"Immutable\" means that once a tuple is created, its contents cannot be changedâ€”you cannot add, remove, or modify elements. Tuples are typically used to store collections of related items where the order and content should remain constant, such as coordinates (x, y), RGB color values (red, green, blue), or records from a database.
            </p>
            <p>Key characteristics of tuples:</p>
            <ul>
              <li><strong>Ordered:</strong> Items are stored in a specific sequence, and this order is maintained.</li>
              <li><strong>Immutable:</strong> Once created, the elements within a tuple cannot be changed, nor can elements be added or removed. This makes tuples safer to use as dictionary keys if all their elements are immutable.</li>
              <li><strong>Allows Duplicates:</strong> Tuples can contain the same item multiple times.</li>
              <li><strong>Heterogeneous:</strong> Tuples can contain items of different data types (e.g., a mix of integers, strings, and floats).</li>
            </ul>
            <h3 class="section-subtitle-8bit smaller-subtitle">Creating Tuples:</h3>
            <p>
              Tuples are created by enclosing a comma-separated sequence of items within parentheses <code>()</code>. Parentheses are optional in many contexts if the commas make the tuple clear, but it's good practice to use them for readability.
            </p>
            <pre><code class="code-block-8bit python"># Creating an empty tuple
empty_tuple_v1 = ()
empty_tuple_v2 = tuple()

# Creating a tuple with items
coordinates = (10, 20, 5) # A 3D point (x, y, z)
primary_colors = ("red", "green", "blue")
player_info = ("PixelPete", 25, 1500.75) # name, age, score

print(f"Coordinates: {coordinates}")
print(f"Type of coordinates: {type(coordinates)}") # Output: <class 'tuple'>

# Parentheses are sometimes optional (tuple packing)
packed_tuple = 1, 'hello', True
print(f"Packed tuple: {packed_tuple}, Type: {type(packed_tuple)}")

# Special case: Single item tuple needs a trailing comma!
single_item_tuple = (99,) # This is a tuple with one element
not_a_tuple_but_int = (99)  # This is just the integer 99 in parentheses
string_in_tuple = ("apple",) # Tuple containing one string

print(f"Single item tuple: {single_item_tuple}, Type: {type(single_item_tuple)}")
print(f"Not a tuple: {not_a_tuple_but_int}, Type: {type(not_a_tuple_but_int)}")</code></pre>
            <h3 class="section-subtitle-8bit smaller-subtitle">Accessing Elements:</h3>
            <p>Elements in a tuple are accessed using indexing (starting from 0), just like lists.</p>
            <pre><code class="code-block-8bit python">rgb_color = (255, 128, 0) # Orange
red_value = rgb_color[0]
print(f"Red: {red_value}") # Output: 255

# Slicing also works like lists
green_and_blue = rgb_color[1:3]
print(f"Green and Blue: {green_and_blue}") # Output: (128, 0)</code></pre>
            <h3 class="section-subtitle-8bit smaller-subtitle">Immutability:</h3>
            <p>Once a tuple is created, you cannot change its elements.</p>
            <pre><code class="code-block-8bit python">my_tuple = (1, 2, 3)
# my_tuple[0] = 100  # This would raise a TypeError: 'tuple' object does not support item assignment
# my_tuple.append(4) # This would raise an AttributeError: 'tuple' object has no attribute 'append'

# However, if a tuple contains a mutable object (like a list), the mutable object itself can be changed.
mutable_in_tuple = ([1, 2], [3, 4])
mutable_in_tuple[0].append(99) # This is allowed, modifies the inner list
print(f"Tuple with modified inner list: {mutable_in_tuple}")
# Output: Tuple with modified inner list: ([1, 2, 99], [3, 4])</code></pre>
            <h3 class="section-subtitle-8bit smaller-subtitle">Tuple Packing and Unpacking:</h3>
            <p>Tuple packing is when you assign a sequence of values to a single variable, implicitly creating a tuple. Unpacking is assigning the elements of a tuple to multiple variables.</p>
            <pre><code class="code-block-8bit python"># Tuple Packing
packed_data = "Player1", 100, "Active" # Creates a tuple
print(f"Packed: {packed_data}")

# Tuple Unpacking
name, health, status = packed_data # Assigns elements to variables
print(f"Name: {name}, Health: {health}, Status: {status}")

# Unpacking can be used for swapping variables elegantly
a = 5
b = 10
a, b = b, a # a becomes 10, b becomes 5 (internally uses tuples)
print(f"Swapped a: {a}, b: {b}")</code></pre>
            <h3 class="section-subtitle-8bit smaller-subtitle">When to Use Tuples:</h3>
            <ul>
                <li>For fixed collections of items that should not change (e.g., coordinates, constants).</li>
                <li>When you need to use a collection as a dictionary key (since keys must be immutable).</li>
                <li>When you want to ensure data integrity (prevent accidental modification).</li>
                <li>Sometimes for slight performance gains over lists in specific scenarios (due to their fixed size and immutability), though this is often minor.</li>
            </ul>
            <h3 class="section-subtitle-8bit smaller-subtitle">Tuple Methods:</h3>
            <p>Tuples have only two main methods because they are immutable:</p>
            <ul>
                <li><code>my_tuple.count(value)</code>: Returns the number of times <code>value</code> appears in the tuple.</li>
                <li><code>my_tuple.index(value)</code>: Returns the index of the first occurrence of <code>value</code>. Raises a <code>ValueError</code> if the value is not found.</li>
            </ul>
            <pre><code class="code-block-8bit python">example_tuple = ('a', 'b', 'c', 'a', 'd', 'a')
print(f"Count of 'a': {example_tuple.count('a')}") # Output: 3
print(f"Index of 'd': {example_tuple.index('d')}") # Output: 4</code></pre>
          </div>
        </section>
      </main>

      <footer class="footer-8bit text-center py-6">
        <p class="text-md md:text-lg">Happy Coding, Player 1!</p>
        <p class="mt-3 md:mt-4">
          <a
            href="../index.html"
            class="link-8bit"
            >Back to Main Menu</a
          >
        </p>
      </footer>
    </div> <!-- End of console-screen-border -->
    <script>
      // No specific JavaScript for this page in the current version,
      // but the structure for dictDisplay, dictResultDisplay, dictMessage is in place
      // for potential future interactivity.
      const dictDisplay = document.getElementById('dictDisplay');
      const dictResultDisplay = document.getElementById('dictResultDisplay');
      // If dictDisplay and dictResultDisplay were to be populated by default or via JS:
      // if (dictDisplay) { dictDisplay.innerHTML = '<p>{ "name": "Hero", "class": "Warrior", "level": 10 }</p>'; }
      // if (dictResultDisplay) { dictResultDisplay.innerHTML = '<p><em>No operation performed yet.</em></p>'; }
    </script>
  </body>
</html>
